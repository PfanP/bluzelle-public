// Generated by dts-bundle-generator v6.12.0

import { DirectSecp256k1HdWallet } from '@cosmjs/proto-signing';
import { DirectSecp256k1HdWalletOptions } from '@cosmjs/proto-signing/build/directsecp256k1hdwallet';
import { AccountData, DirectSignResponse, OfflineDirectSigner } from '@cosmjs/proto-signing/build/signer';
import { DeliverTxResponse, SequenceResponse, SigningStargateClient } from '@cosmjs/stargate';
import { SigningStargateClientOptions } from '@cosmjs/stargate/build/signingstargateclient';
import { Tendermint34Client } from '@cosmjs/tendermint-rpc';
import Long from 'long';

export interface QueryHasContentRequest {
	cid: string;
}
export interface QueryHasContentResponse {
	hasContent: boolean;
}
declare const QueryHasContentRequest: {
	encode(message: QueryHasContentRequest, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryHasContentRequest;
	fromJSON(object: any): QueryHasContentRequest;
	toJSON(message: QueryHasContentRequest): unknown;
	fromPartial<I extends {
		cid?: string;
	} & {
		cid?: string;
	} & Record<Exclude<keyof I, "cid">, never>>(object: I): QueryHasContentRequest;
};
declare const QueryHasContentResponse: {
	encode(message: QueryHasContentResponse, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryHasContentResponse;
	fromJSON(object: any): QueryHasContentResponse;
	toJSON(message: QueryHasContentResponse): unknown;
	fromPartial<I extends {
		hasContent?: boolean;
	} & {
		hasContent?: boolean;
	} & Record<Exclude<keyof I, "hasContent">, never>>(object: I): QueryHasContentResponse;
};
/** Query defines the gRPC querier service. */
export interface Query {
	HasContent(request: QueryHasContentRequest): Promise<QueryHasContentResponse>;
}
declare class QueryClientImpl implements Query {
	private readonly rpc;
	constructor(rpc: Rpc);
	HasContent(request: QueryHasContentRequest): Promise<QueryHasContentResponse>;
}
export interface Rpc {
	request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}
/**
 * Coin defines a token with a denomination and an amount.
 *
 * NOTE: The amount field is an Int which implements the custom method
 * signatures required by gogoproto.
 */
export interface Coin {
	denom: string;
	amount: string;
}
declare const Coin: {
	encode(message: Coin, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): Coin;
	fromJSON(object: any): Coin;
	toJSON(message: Coin): unknown;
	fromPartial<I extends {
		denom?: string;
		amount?: string;
	} & {
		denom?: string;
		amount?: string;
	} & Record<Exclude<keyof I, keyof Coin>, never>>(object: I): Coin;
};
/**
 * PageRequest is to be embedded in gRPC request messages for efficient
 * pagination. Ex:
 *
 *  message SomeRequest {
 *          Foo some_parameter = 1;
 *          PageRequest pagination = 2;
 *  }
 */
export interface PageRequest {
	/**
	 * key is a value returned in PageResponse.next_key to begin
	 * querying the next page most efficiently. Only one of offset or key
	 * should be set.
	 */
	key: Uint8Array;
	/**
	 * offset is a numeric offset that can be used when key is unavailable.
	 * It is less efficient than using key. Only one of offset or key should
	 * be set.
	 */
	offset: Long;
	/**
	 * limit is the total number of results to be returned in the result page.
	 * If left empty it will default to a value to be set by each app.
	 */
	limit: Long;
	/**
	 * count_total is set to true  to indicate that the result set should include
	 * a count of the total number of items available for pagination in UIs.
	 * count_total is only respected when offset is used. It is ignored when key
	 * is set.
	 */
	countTotal: boolean;
	/** reverse is set to true if results are to be returned in the descending order. */
	reverse: boolean;
}
/**
 * PageResponse is to be embedded in gRPC response messages where the
 * corresponding request message has used PageRequest.
 *
 *  message SomeResponse {
 *          repeated Bar results = 1;
 *          PageResponse page = 2;
 *  }
 */
export interface PageResponse {
	/**
	 * next_key is the key to be passed to PageRequest.key to
	 * query the next page most efficiently
	 */
	nextKey: Uint8Array;
	/**
	 * total is total number of results available if PageRequest.count_total
	 * was set, its value is undefined otherwise
	 */
	total: Long;
}
declare const PageRequest: {
	encode(message: PageRequest, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): PageRequest;
	fromJSON(object: any): PageRequest;
	toJSON(message: PageRequest): unknown;
	fromPartial<I extends {
		key?: Uint8Array;
		offset?: string | number | Long.Long;
		limit?: string | number | Long.Long;
		countTotal?: boolean;
		reverse?: boolean;
	} & {
		key?: Uint8Array;
		offset?: string | number | (Long.Long & {
			high: number;
			low: number;
			unsigned: boolean;
			add: (addend: string | number | Long.Long) => Long.Long;
			and: (other: string | number | Long.Long) => Long.Long;
			compare: (other: string | number | Long.Long) => number;
			comp: (other: string | number | Long.Long) => number;
			divide: (divisor: string | number | Long.Long) => Long.Long;
			div: (divisor: string | number | Long.Long) => Long.Long;
			equals: (other: string | number | Long.Long) => boolean;
			eq: (other: string | number | Long.Long) => boolean;
			getHighBits: () => number;
			getHighBitsUnsigned: () => number;
			getLowBits: () => number;
			getLowBitsUnsigned: () => number;
			getNumBitsAbs: () => number;
			greaterThan: (other: string | number | Long.Long) => boolean;
			gt: (other: string | number | Long.Long) => boolean;
			greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
			gte: (other: string | number | Long.Long) => boolean;
			isEven: () => boolean;
			isNegative: () => boolean;
			isOdd: () => boolean;
			isPositive: () => boolean;
			isZero: () => boolean;
			lessThan: (other: string | number | Long.Long) => boolean;
			lt: (other: string | number | Long.Long) => boolean;
			lessThanOrEqual: (other: string | number | Long.Long) => boolean;
			lte: (other: string | number | Long.Long) => boolean;
			modulo: (other: string | number | Long.Long) => Long.Long;
			mod: (other: string | number | Long.Long) => Long.Long;
			multiply: (multiplier: string | number | Long.Long) => Long.Long;
			mul: (multiplier: string | number | Long.Long) => Long.Long;
			negate: () => Long.Long;
			neg: () => Long.Long;
			not: () => Long.Long;
			notEquals: (other: string | number | Long.Long) => boolean;
			neq: (other: string | number | Long.Long) => boolean;
			or: (other: string | number | Long.Long) => Long.Long;
			shiftLeft: (numBits: number | Long.Long) => Long.Long;
			shl: (numBits: number | Long.Long) => Long.Long;
			shiftRight: (numBits: number | Long.Long) => Long.Long;
			shr: (numBits: number | Long.Long) => Long.Long;
			shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
			shru: (numBits: number | Long.Long) => Long.Long;
			subtract: (subtrahend: string | number | Long.Long) => Long.Long;
			sub: (subtrahend: string | number | Long.Long) => Long.Long;
			toInt: () => number;
			toNumber: () => number;
			toBytes: (le?: boolean) => number[];
			toBytesLE: () => number[];
			toBytesBE: () => number[];
			toSigned: () => Long.Long;
			toString: (radix?: number) => string;
			toUnsigned: () => Long.Long;
			xor: (other: string | number | Long.Long) => Long.Long;
		} & Record<Exclude<keyof I["offset"], keyof Long.Long>, never>);
		limit?: string | number | (Long.Long & {
			high: number;
			low: number;
			unsigned: boolean;
			add: (addend: string | number | Long.Long) => Long.Long;
			and: (other: string | number | Long.Long) => Long.Long;
			compare: (other: string | number | Long.Long) => number;
			comp: (other: string | number | Long.Long) => number;
			divide: (divisor: string | number | Long.Long) => Long.Long;
			div: (divisor: string | number | Long.Long) => Long.Long;
			equals: (other: string | number | Long.Long) => boolean;
			eq: (other: string | number | Long.Long) => boolean;
			getHighBits: () => number;
			getHighBitsUnsigned: () => number;
			getLowBits: () => number;
			getLowBitsUnsigned: () => number;
			getNumBitsAbs: () => number;
			greaterThan: (other: string | number | Long.Long) => boolean;
			gt: (other: string | number | Long.Long) => boolean;
			greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
			gte: (other: string | number | Long.Long) => boolean;
			isEven: () => boolean;
			isNegative: () => boolean;
			isOdd: () => boolean;
			isPositive: () => boolean;
			isZero: () => boolean;
			lessThan: (other: string | number | Long.Long) => boolean;
			lt: (other: string | number | Long.Long) => boolean;
			lessThanOrEqual: (other: string | number | Long.Long) => boolean;
			lte: (other: string | number | Long.Long) => boolean;
			modulo: (other: string | number | Long.Long) => Long.Long;
			mod: (other: string | number | Long.Long) => Long.Long;
			multiply: (multiplier: string | number | Long.Long) => Long.Long;
			mul: (multiplier: string | number | Long.Long) => Long.Long;
			negate: () => Long.Long;
			neg: () => Long.Long;
			not: () => Long.Long;
			notEquals: (other: string | number | Long.Long) => boolean;
			neq: (other: string | number | Long.Long) => boolean;
			or: (other: string | number | Long.Long) => Long.Long;
			shiftLeft: (numBits: number | Long.Long) => Long.Long;
			shl: (numBits: number | Long.Long) => Long.Long;
			shiftRight: (numBits: number | Long.Long) => Long.Long;
			shr: (numBits: number | Long.Long) => Long.Long;
			shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
			shru: (numBits: number | Long.Long) => Long.Long;
			subtract: (subtrahend: string | number | Long.Long) => Long.Long;
			sub: (subtrahend: string | number | Long.Long) => Long.Long;
			toInt: () => number;
			toNumber: () => number;
			toBytes: (le?: boolean) => number[];
			toBytesLE: () => number[];
			toBytesBE: () => number[];
			toSigned: () => Long.Long;
			toString: (radix?: number) => string;
			toUnsigned: () => Long.Long;
			xor: (other: string | number | Long.Long) => Long.Long;
		} & Record<Exclude<keyof I["limit"], keyof Long.Long>, never>);
		countTotal?: boolean;
		reverse?: boolean;
	} & Record<Exclude<keyof I, keyof PageRequest>, never>>(object: I): PageRequest;
};
declare const PageResponse: {
	encode(message: PageResponse, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): PageResponse;
	fromJSON(object: any): PageResponse;
	toJSON(message: PageResponse): unknown;
	fromPartial<I extends {
		nextKey?: Uint8Array;
		total?: string | number | Long.Long;
	} & {
		nextKey?: Uint8Array;
		total?: string | number | (Long.Long & {
			high: number;
			low: number;
			unsigned: boolean;
			add: (addend: string | number | Long.Long) => Long.Long;
			and: (other: string | number | Long.Long) => Long.Long;
			compare: (other: string | number | Long.Long) => number;
			comp: (other: string | number | Long.Long) => number;
			divide: (divisor: string | number | Long.Long) => Long.Long;
			div: (divisor: string | number | Long.Long) => Long.Long;
			equals: (other: string | number | Long.Long) => boolean;
			eq: (other: string | number | Long.Long) => boolean;
			getHighBits: () => number;
			getHighBitsUnsigned: () => number;
			getLowBits: () => number;
			getLowBitsUnsigned: () => number;
			getNumBitsAbs: () => number;
			greaterThan: (other: string | number | Long.Long) => boolean;
			gt: (other: string | number | Long.Long) => boolean;
			greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
			gte: (other: string | number | Long.Long) => boolean;
			isEven: () => boolean;
			isNegative: () => boolean;
			isOdd: () => boolean;
			isPositive: () => boolean;
			isZero: () => boolean;
			lessThan: (other: string | number | Long.Long) => boolean;
			lt: (other: string | number | Long.Long) => boolean;
			lessThanOrEqual: (other: string | number | Long.Long) => boolean;
			lte: (other: string | number | Long.Long) => boolean;
			modulo: (other: string | number | Long.Long) => Long.Long;
			mod: (other: string | number | Long.Long) => Long.Long;
			multiply: (multiplier: string | number | Long.Long) => Long.Long;
			mul: (multiplier: string | number | Long.Long) => Long.Long;
			negate: () => Long.Long;
			neg: () => Long.Long;
			not: () => Long.Long;
			notEquals: (other: string | number | Long.Long) => boolean;
			neq: (other: string | number | Long.Long) => boolean;
			or: (other: string | number | Long.Long) => Long.Long;
			shiftLeft: (numBits: number | Long.Long) => Long.Long;
			shl: (numBits: number | Long.Long) => Long.Long;
			shiftRight: (numBits: number | Long.Long) => Long.Long;
			shr: (numBits: number | Long.Long) => Long.Long;
			shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
			shru: (numBits: number | Long.Long) => Long.Long;
			subtract: (subtrahend: string | number | Long.Long) => Long.Long;
			sub: (subtrahend: string | number | Long.Long) => Long.Long;
			toInt: () => number;
			toNumber: () => number;
			toBytes: (le?: boolean) => number[];
			toBytesLE: () => number[];
			toBytesBE: () => number[];
			toSigned: () => Long.Long;
			toString: (radix?: number) => string;
			toUnsigned: () => Long.Long;
			xor: (other: string | number | Long.Long) => Long.Long;
		} & Record<Exclude<keyof I["total"], keyof Long.Long>, never>);
	} & Record<Exclude<keyof I, keyof PageResponse>, never>>(object: I): PageResponse;
};
/** Params defines the parameters for the bank module. */
export interface Params {
	sendEnabled: SendEnabled[];
	defaultSendEnabled: boolean;
}
/**
 * SendEnabled maps coin denom to a send_enabled status (whether a denom is
 * sendable).
 */
export interface SendEnabled {
	denom: string;
	enabled: boolean;
}
/**
 * DenomUnit represents a struct that describes a given
 * denomination unit of the basic token.
 */
export interface DenomUnit {
	/** denom represents the string name of the given denom unit (e.g uatom). */
	denom: string;
	/**
	 * exponent represents power of 10 exponent that one must
	 * raise the base_denom to in order to equal the given DenomUnit's denom
	 * 1 denom = 1^exponent base_denom
	 * (e.g. with a base_denom of uatom, one can create a DenomUnit of 'atom' with
	 * exponent = 6, thus: 1 atom = 10^6 uatom).
	 */
	exponent: number;
	/** aliases is a list of string aliases for the given denom */
	aliases: string[];
}
/**
 * Metadata represents a struct that describes
 * a basic token.
 */
export interface Metadata {
	description: string;
	/** denom_units represents the list of DenomUnit's for a given coin */
	denomUnits: DenomUnit[];
	/** base represents the base denom (should be the DenomUnit with exponent = 0). */
	base: string;
	/**
	 * display indicates the suggested denom that should be
	 * displayed in clients.
	 */
	display: string;
	/** name defines the name of the token (eg: Cosmos Atom) */
	name: string;
	/**
	 * symbol is the token symbol usually shown on exchanges (eg: ATOM). This can
	 * be the same as the display.
	 */
	symbol: string;
}
declare const Params: {
	encode(message: Params, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): Params;
	fromJSON(object: any): Params;
	toJSON(message: Params): unknown;
	fromPartial<I extends {
		sendEnabled?: {
			denom?: string;
			enabled?: boolean;
		}[];
		defaultSendEnabled?: boolean;
	} & {
		sendEnabled?: {
			denom?: string;
			enabled?: boolean;
		}[] & ({
			denom?: string;
			enabled?: boolean;
		} & {
			denom?: string;
			enabled?: boolean;
		} & Record<Exclude<keyof I["sendEnabled"][number], keyof SendEnabled>, never>)[] & Record<Exclude<keyof I["sendEnabled"], keyof {
			denom?: string;
			enabled?: boolean;
		}[]>, never>;
		defaultSendEnabled?: boolean;
	} & Record<Exclude<keyof I, keyof Params>, never>>(object: I): Params;
};
declare const SendEnabled: {
	encode(message: SendEnabled, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): SendEnabled;
	fromJSON(object: any): SendEnabled;
	toJSON(message: SendEnabled): unknown;
	fromPartial<I extends {
		denom?: string;
		enabled?: boolean;
	} & {
		denom?: string;
		enabled?: boolean;
	} & Record<Exclude<keyof I, keyof SendEnabled>, never>>(object: I): SendEnabled;
};
declare const DenomUnit: {
	encode(message: DenomUnit, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): DenomUnit;
	fromJSON(object: any): DenomUnit;
	toJSON(message: DenomUnit): unknown;
	fromPartial<I extends {
		denom?: string;
		exponent?: number;
		aliases?: string[];
	} & {
		denom?: string;
		exponent?: number;
		aliases?: string[] & string[] & Record<Exclude<keyof I["aliases"], keyof string[]>, never>;
	} & Record<Exclude<keyof I, keyof DenomUnit>, never>>(object: I): DenomUnit;
};
declare const Metadata: {
	encode(message: Metadata, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): Metadata;
	fromJSON(object: any): Metadata;
	toJSON(message: Metadata): unknown;
	fromPartial<I extends {
		description?: string;
		denomUnits?: {
			denom?: string;
			exponent?: number;
			aliases?: string[];
		}[];
		base?: string;
		display?: string;
		name?: string;
		symbol?: string;
	} & {
		description?: string;
		denomUnits?: {
			denom?: string;
			exponent?: number;
			aliases?: string[];
		}[] & ({
			denom?: string;
			exponent?: number;
			aliases?: string[];
		} & {
			denom?: string;
			exponent?: number;
			aliases?: string[] & string[] & Record<Exclude<keyof I["denomUnits"][number]["aliases"], keyof string[]>, never>;
		} & Record<Exclude<keyof I["denomUnits"][number], keyof DenomUnit>, never>)[] & Record<Exclude<keyof I["denomUnits"], keyof {
			denom?: string;
			exponent?: number;
			aliases?: string[];
		}[]>, never>;
		base?: string;
		display?: string;
		name?: string;
		symbol?: string;
	} & Record<Exclude<keyof I, keyof Metadata>, never>>(object: I): Metadata;
};
/** QueryBalanceRequest is the request type for the Query/Balance RPC method. */
export interface QueryBalanceRequest {
	/** address is the address to query balances for. */
	address: string;
	/** denom is the coin denom to query balances for. */
	denom: string;
}
/** QueryBalanceResponse is the response type for the Query/Balance RPC method. */
export interface QueryBalanceResponse {
	/** balance is the balance of the coin. */
	balance?: Coin;
}
/** QueryBalanceRequest is the request type for the Query/AllBalances RPC method. */
export interface QueryAllBalancesRequest {
	/** address is the address to query balances for. */
	address: string;
	/** pagination defines an optional pagination for the request. */
	pagination?: PageRequest;
}
/**
 * QueryAllBalancesResponse is the response type for the Query/AllBalances RPC
 * method.
 */
export interface QueryAllBalancesResponse {
	/** balances is the balances of all the coins. */
	balances: Coin[];
	/** pagination defines the pagination in the response. */
	pagination?: PageResponse;
}
/**
 * QueryTotalSupplyRequest is the request type for the Query/TotalSupply RPC
 * method.
 */
export interface QueryTotalSupplyRequest {
	/** pagination defines an optional pagination for the request. */
	pagination?: PageRequest;
}
/**
 * QueryTotalSupplyResponse is the response type for the Query/TotalSupply RPC
 * method
 */
export interface QueryTotalSupplyResponse {
	/** supply is the supply of the coins */
	supply: Coin[];
	/** pagination defines the pagination in the response. */
	pagination?: PageResponse;
}
/** QuerySupplyOfRequest is the request type for the Query/SupplyOf RPC method. */
export interface QuerySupplyOfRequest {
	/** denom is the coin denom to query balances for. */
	denom: string;
}
/** QuerySupplyOfResponse is the response type for the Query/SupplyOf RPC method. */
export interface QuerySupplyOfResponse {
	/** amount is the supply of the coin. */
	amount?: Coin;
}
/** QueryParamsRequest defines the request type for querying x/bank parameters. */
export interface QueryParamsRequest {
}
/** QueryParamsResponse defines the response type for querying x/bank parameters. */
export interface QueryParamsResponse {
	params?: Params;
}
/** QueryDenomsMetadataRequest is the request type for the Query/DenomsMetadata RPC method. */
export interface QueryDenomsMetadataRequest {
	/** pagination defines an optional pagination for the request. */
	pagination?: PageRequest;
}
/**
 * QueryDenomsMetadataResponse is the response type for the Query/DenomsMetadata RPC
 * method.
 */
export interface QueryDenomsMetadataResponse {
	/** metadata provides the client information for all the registered tokens. */
	metadatas: Metadata[];
	/** pagination defines the pagination in the response. */
	pagination?: PageResponse;
}
/** QueryDenomMetadataRequest is the request type for the Query/DenomMetadata RPC method. */
export interface QueryDenomMetadataRequest {
	/** denom is the coin denom to query the metadata for. */
	denom: string;
}
/**
 * QueryDenomMetadataResponse is the response type for the Query/DenomMetadata RPC
 * method.
 */
export interface QueryDenomMetadataResponse {
	/** metadata describes and provides all the client information for the requested token. */
	metadata?: Metadata;
}
declare const QueryBalanceRequest: {
	encode(message: QueryBalanceRequest, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryBalanceRequest;
	fromJSON(object: any): QueryBalanceRequest;
	toJSON(message: QueryBalanceRequest): unknown;
	fromPartial<I extends {
		address?: string;
		denom?: string;
	} & {
		address?: string;
		denom?: string;
	} & Record<Exclude<keyof I, keyof QueryBalanceRequest>, never>>(object: I): QueryBalanceRequest;
};
declare const QueryBalanceResponse: {
	encode(message: QueryBalanceResponse, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryBalanceResponse;
	fromJSON(object: any): QueryBalanceResponse;
	toJSON(message: QueryBalanceResponse): unknown;
	fromPartial<I extends {
		balance?: {
			denom?: string;
			amount?: string;
		};
	} & {
		balance?: {
			denom?: string;
			amount?: string;
		} & {
			denom?: string;
			amount?: string;
		} & Record<Exclude<keyof I["balance"], keyof Coin>, never>;
	} & Record<Exclude<keyof I, "balance">, never>>(object: I): QueryBalanceResponse;
};
declare const QueryAllBalancesRequest: {
	encode(message: QueryAllBalancesRequest, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryAllBalancesRequest;
	fromJSON(object: any): QueryAllBalancesRequest;
	toJSON(message: QueryAllBalancesRequest): unknown;
	fromPartial<I extends {
		address?: string;
		pagination?: {
			key?: Uint8Array;
			offset?: string | number | Long.Long;
			limit?: string | number | Long.Long;
			countTotal?: boolean;
			reverse?: boolean;
		};
	} & {
		address?: string;
		pagination?: {
			key?: Uint8Array;
			offset?: string | number | Long.Long;
			limit?: string | number | Long.Long;
			countTotal?: boolean;
			reverse?: boolean;
		} & {
			key?: Uint8Array;
			offset?: string | number | (Long.Long & {
				high: number;
				low: number;
				unsigned: boolean;
				add: (addend: string | number | Long.Long) => Long.Long;
				and: (other: string | number | Long.Long) => Long.Long;
				compare: (other: string | number | Long.Long) => number;
				comp: (other: string | number | Long.Long) => number;
				divide: (divisor: string | number | Long.Long) => Long.Long;
				div: (divisor: string | number | Long.Long) => Long.Long;
				equals: (other: string | number | Long.Long) => boolean;
				eq: (other: string | number | Long.Long) => boolean;
				getHighBits: () => number;
				getHighBitsUnsigned: () => number;
				getLowBits: () => number;
				getLowBitsUnsigned: () => number;
				getNumBitsAbs: () => number;
				greaterThan: (other: string | number | Long.Long) => boolean;
				gt: (other: string | number | Long.Long) => boolean;
				greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
				gte: (other: string | number | Long.Long) => boolean;
				isEven: () => boolean;
				isNegative: () => boolean;
				isOdd: () => boolean;
				isPositive: () => boolean;
				isZero: () => boolean;
				lessThan: (other: string | number | Long.Long) => boolean;
				lt: (other: string | number | Long.Long) => boolean;
				lessThanOrEqual: (other: string | number | Long.Long) => boolean;
				lte: (other: string | number | Long.Long) => boolean;
				modulo: (other: string | number | Long.Long) => Long.Long;
				mod: (other: string | number | Long.Long) => Long.Long;
				multiply: (multiplier: string | number | Long.Long) => Long.Long;
				mul: (multiplier: string | number | Long.Long) => Long.Long;
				negate: () => Long.Long;
				neg: () => Long.Long;
				not: () => Long.Long;
				notEquals: (other: string | number | Long.Long) => boolean;
				neq: (other: string | number | Long.Long) => boolean;
				or: (other: string | number | Long.Long) => Long.Long;
				shiftLeft: (numBits: number | Long.Long) => Long.Long;
				shl: (numBits: number | Long.Long) => Long.Long;
				shiftRight: (numBits: number | Long.Long) => Long.Long;
				shr: (numBits: number | Long.Long) => Long.Long;
				shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
				shru: (numBits: number | Long.Long) => Long.Long;
				subtract: (subtrahend: string | number | Long.Long) => Long.Long;
				sub: (subtrahend: string | number | Long.Long) => Long.Long;
				toInt: () => number;
				toNumber: () => number;
				toBytes: (le?: boolean) => number[];
				toBytesLE: () => number[];
				toBytesBE: () => number[];
				toSigned: () => Long.Long;
				toString: (radix?: number) => string;
				toUnsigned: () => Long.Long;
				xor: (other: string | number | Long.Long) => Long.Long;
			} & Record<Exclude<keyof I["pagination"]["offset"], keyof Long.Long>, never>);
			limit?: string | number | (Long.Long & {
				high: number;
				low: number;
				unsigned: boolean;
				add: (addend: string | number | Long.Long) => Long.Long;
				and: (other: string | number | Long.Long) => Long.Long;
				compare: (other: string | number | Long.Long) => number;
				comp: (other: string | number | Long.Long) => number;
				divide: (divisor: string | number | Long.Long) => Long.Long;
				div: (divisor: string | number | Long.Long) => Long.Long;
				equals: (other: string | number | Long.Long) => boolean;
				eq: (other: string | number | Long.Long) => boolean;
				getHighBits: () => number;
				getHighBitsUnsigned: () => number;
				getLowBits: () => number;
				getLowBitsUnsigned: () => number;
				getNumBitsAbs: () => number;
				greaterThan: (other: string | number | Long.Long) => boolean;
				gt: (other: string | number | Long.Long) => boolean;
				greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
				gte: (other: string | number | Long.Long) => boolean;
				isEven: () => boolean;
				isNegative: () => boolean;
				isOdd: () => boolean;
				isPositive: () => boolean;
				isZero: () => boolean;
				lessThan: (other: string | number | Long.Long) => boolean;
				lt: (other: string | number | Long.Long) => boolean;
				lessThanOrEqual: (other: string | number | Long.Long) => boolean;
				lte: (other: string | number | Long.Long) => boolean;
				modulo: (other: string | number | Long.Long) => Long.Long;
				mod: (other: string | number | Long.Long) => Long.Long;
				multiply: (multiplier: string | number | Long.Long) => Long.Long;
				mul: (multiplier: string | number | Long.Long) => Long.Long;
				negate: () => Long.Long;
				neg: () => Long.Long;
				not: () => Long.Long;
				notEquals: (other: string | number | Long.Long) => boolean;
				neq: (other: string | number | Long.Long) => boolean;
				or: (other: string | number | Long.Long) => Long.Long;
				shiftLeft: (numBits: number | Long.Long) => Long.Long;
				shl: (numBits: number | Long.Long) => Long.Long;
				shiftRight: (numBits: number | Long.Long) => Long.Long;
				shr: (numBits: number | Long.Long) => Long.Long;
				shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
				shru: (numBits: number | Long.Long) => Long.Long;
				subtract: (subtrahend: string | number | Long.Long) => Long.Long;
				sub: (subtrahend: string | number | Long.Long) => Long.Long;
				toInt: () => number;
				toNumber: () => number;
				toBytes: (le?: boolean) => number[];
				toBytesLE: () => number[];
				toBytesBE: () => number[];
				toSigned: () => Long.Long;
				toString: (radix?: number) => string;
				toUnsigned: () => Long.Long;
				xor: (other: string | number | Long.Long) => Long.Long;
			} & Record<Exclude<keyof I["pagination"]["limit"], keyof Long.Long>, never>);
			countTotal?: boolean;
			reverse?: boolean;
		} & Record<Exclude<keyof I["pagination"], keyof PageRequest>, never>;
	} & Record<Exclude<keyof I, keyof QueryAllBalancesRequest>, never>>(object: I): QueryAllBalancesRequest;
};
declare const QueryAllBalancesResponse: {
	encode(message: QueryAllBalancesResponse, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryAllBalancesResponse;
	fromJSON(object: any): QueryAllBalancesResponse;
	toJSON(message: QueryAllBalancesResponse): unknown;
	fromPartial<I extends {
		balances?: {
			denom?: string;
			amount?: string;
		}[];
		pagination?: {
			nextKey?: Uint8Array;
			total?: string | number | Long.Long;
		};
	} & {
		balances?: {
			denom?: string;
			amount?: string;
		}[] & ({
			denom?: string;
			amount?: string;
		} & {
			denom?: string;
			amount?: string;
		} & Record<Exclude<keyof I["balances"][number], keyof Coin>, never>)[] & Record<Exclude<keyof I["balances"], keyof {
			denom?: string;
			amount?: string;
		}[]>, never>;
		pagination?: {
			nextKey?: Uint8Array;
			total?: string | number | Long.Long;
		} & {
			nextKey?: Uint8Array;
			total?: string | number | (Long.Long & {
				high: number;
				low: number;
				unsigned: boolean;
				add: (addend: string | number | Long.Long) => Long.Long;
				and: (other: string | number | Long.Long) => Long.Long;
				compare: (other: string | number | Long.Long) => number;
				comp: (other: string | number | Long.Long) => number;
				divide: (divisor: string | number | Long.Long) => Long.Long;
				div: (divisor: string | number | Long.Long) => Long.Long;
				equals: (other: string | number | Long.Long) => boolean;
				eq: (other: string | number | Long.Long) => boolean;
				getHighBits: () => number;
				getHighBitsUnsigned: () => number;
				getLowBits: () => number;
				getLowBitsUnsigned: () => number;
				getNumBitsAbs: () => number;
				greaterThan: (other: string | number | Long.Long) => boolean;
				gt: (other: string | number | Long.Long) => boolean;
				greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
				gte: (other: string | number | Long.Long) => boolean;
				isEven: () => boolean;
				isNegative: () => boolean;
				isOdd: () => boolean;
				isPositive: () => boolean;
				isZero: () => boolean;
				lessThan: (other: string | number | Long.Long) => boolean;
				lt: (other: string | number | Long.Long) => boolean;
				lessThanOrEqual: (other: string | number | Long.Long) => boolean;
				lte: (other: string | number | Long.Long) => boolean;
				modulo: (other: string | number | Long.Long) => Long.Long;
				mod: (other: string | number | Long.Long) => Long.Long;
				multiply: (multiplier: string | number | Long.Long) => Long.Long;
				mul: (multiplier: string | number | Long.Long) => Long.Long;
				negate: () => Long.Long;
				neg: () => Long.Long;
				not: () => Long.Long;
				notEquals: (other: string | number | Long.Long) => boolean;
				neq: (other: string | number | Long.Long) => boolean;
				or: (other: string | number | Long.Long) => Long.Long;
				shiftLeft: (numBits: number | Long.Long) => Long.Long;
				shl: (numBits: number | Long.Long) => Long.Long;
				shiftRight: (numBits: number | Long.Long) => Long.Long;
				shr: (numBits: number | Long.Long) => Long.Long;
				shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
				shru: (numBits: number | Long.Long) => Long.Long;
				subtract: (subtrahend: string | number | Long.Long) => Long.Long;
				sub: (subtrahend: string | number | Long.Long) => Long.Long;
				toInt: () => number;
				toNumber: () => number;
				toBytes: (le?: boolean) => number[];
				toBytesLE: () => number[];
				toBytesBE: () => number[];
				toSigned: () => Long.Long;
				toString: (radix?: number) => string;
				toUnsigned: () => Long.Long;
				xor: (other: string | number | Long.Long) => Long.Long;
			} & Record<Exclude<keyof I["pagination"]["total"], keyof Long.Long>, never>);
		} & Record<Exclude<keyof I["pagination"], keyof PageResponse>, never>;
	} & Record<Exclude<keyof I, keyof QueryAllBalancesResponse>, never>>(object: I): QueryAllBalancesResponse;
};
declare const QueryTotalSupplyRequest: {
	encode(message: QueryTotalSupplyRequest, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryTotalSupplyRequest;
	fromJSON(object: any): QueryTotalSupplyRequest;
	toJSON(message: QueryTotalSupplyRequest): unknown;
	fromPartial<I extends {
		pagination?: {
			key?: Uint8Array;
			offset?: string | number | Long.Long;
			limit?: string | number | Long.Long;
			countTotal?: boolean;
			reverse?: boolean;
		};
	} & {
		pagination?: {
			key?: Uint8Array;
			offset?: string | number | Long.Long;
			limit?: string | number | Long.Long;
			countTotal?: boolean;
			reverse?: boolean;
		} & {
			key?: Uint8Array;
			offset?: string | number | (Long.Long & {
				high: number;
				low: number;
				unsigned: boolean;
				add: (addend: string | number | Long.Long) => Long.Long;
				and: (other: string | number | Long.Long) => Long.Long;
				compare: (other: string | number | Long.Long) => number;
				comp: (other: string | number | Long.Long) => number;
				divide: (divisor: string | number | Long.Long) => Long.Long;
				div: (divisor: string | number | Long.Long) => Long.Long;
				equals: (other: string | number | Long.Long) => boolean;
				eq: (other: string | number | Long.Long) => boolean;
				getHighBits: () => number;
				getHighBitsUnsigned: () => number;
				getLowBits: () => number;
				getLowBitsUnsigned: () => number;
				getNumBitsAbs: () => number;
				greaterThan: (other: string | number | Long.Long) => boolean;
				gt: (other: string | number | Long.Long) => boolean;
				greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
				gte: (other: string | number | Long.Long) => boolean;
				isEven: () => boolean;
				isNegative: () => boolean;
				isOdd: () => boolean;
				isPositive: () => boolean;
				isZero: () => boolean;
				lessThan: (other: string | number | Long.Long) => boolean;
				lt: (other: string | number | Long.Long) => boolean;
				lessThanOrEqual: (other: string | number | Long.Long) => boolean;
				lte: (other: string | number | Long.Long) => boolean;
				modulo: (other: string | number | Long.Long) => Long.Long;
				mod: (other: string | number | Long.Long) => Long.Long;
				multiply: (multiplier: string | number | Long.Long) => Long.Long;
				mul: (multiplier: string | number | Long.Long) => Long.Long;
				negate: () => Long.Long;
				neg: () => Long.Long;
				not: () => Long.Long;
				notEquals: (other: string | number | Long.Long) => boolean;
				neq: (other: string | number | Long.Long) => boolean;
				or: (other: string | number | Long.Long) => Long.Long;
				shiftLeft: (numBits: number | Long.Long) => Long.Long;
				shl: (numBits: number | Long.Long) => Long.Long;
				shiftRight: (numBits: number | Long.Long) => Long.Long;
				shr: (numBits: number | Long.Long) => Long.Long;
				shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
				shru: (numBits: number | Long.Long) => Long.Long;
				subtract: (subtrahend: string | number | Long.Long) => Long.Long;
				sub: (subtrahend: string | number | Long.Long) => Long.Long;
				toInt: () => number;
				toNumber: () => number;
				toBytes: (le?: boolean) => number[];
				toBytesLE: () => number[];
				toBytesBE: () => number[];
				toSigned: () => Long.Long;
				toString: (radix?: number) => string;
				toUnsigned: () => Long.Long;
				xor: (other: string | number | Long.Long) => Long.Long;
			} & Record<Exclude<keyof I["pagination"]["offset"], keyof Long.Long>, never>);
			limit?: string | number | (Long.Long & {
				high: number;
				low: number;
				unsigned: boolean;
				add: (addend: string | number | Long.Long) => Long.Long;
				and: (other: string | number | Long.Long) => Long.Long;
				compare: (other: string | number | Long.Long) => number;
				comp: (other: string | number | Long.Long) => number;
				divide: (divisor: string | number | Long.Long) => Long.Long;
				div: (divisor: string | number | Long.Long) => Long.Long;
				equals: (other: string | number | Long.Long) => boolean;
				eq: (other: string | number | Long.Long) => boolean;
				getHighBits: () => number;
				getHighBitsUnsigned: () => number;
				getLowBits: () => number;
				getLowBitsUnsigned: () => number;
				getNumBitsAbs: () => number;
				greaterThan: (other: string | number | Long.Long) => boolean;
				gt: (other: string | number | Long.Long) => boolean;
				greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
				gte: (other: string | number | Long.Long) => boolean;
				isEven: () => boolean;
				isNegative: () => boolean;
				isOdd: () => boolean;
				isPositive: () => boolean;
				isZero: () => boolean;
				lessThan: (other: string | number | Long.Long) => boolean;
				lt: (other: string | number | Long.Long) => boolean;
				lessThanOrEqual: (other: string | number | Long.Long) => boolean;
				lte: (other: string | number | Long.Long) => boolean;
				modulo: (other: string | number | Long.Long) => Long.Long;
				mod: (other: string | number | Long.Long) => Long.Long;
				multiply: (multiplier: string | number | Long.Long) => Long.Long;
				mul: (multiplier: string | number | Long.Long) => Long.Long;
				negate: () => Long.Long;
				neg: () => Long.Long;
				not: () => Long.Long;
				notEquals: (other: string | number | Long.Long) => boolean;
				neq: (other: string | number | Long.Long) => boolean;
				or: (other: string | number | Long.Long) => Long.Long;
				shiftLeft: (numBits: number | Long.Long) => Long.Long;
				shl: (numBits: number | Long.Long) => Long.Long;
				shiftRight: (numBits: number | Long.Long) => Long.Long;
				shr: (numBits: number | Long.Long) => Long.Long;
				shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
				shru: (numBits: number | Long.Long) => Long.Long;
				subtract: (subtrahend: string | number | Long.Long) => Long.Long;
				sub: (subtrahend: string | number | Long.Long) => Long.Long;
				toInt: () => number;
				toNumber: () => number;
				toBytes: (le?: boolean) => number[];
				toBytesLE: () => number[];
				toBytesBE: () => number[];
				toSigned: () => Long.Long;
				toString: (radix?: number) => string;
				toUnsigned: () => Long.Long;
				xor: (other: string | number | Long.Long) => Long.Long;
			} & Record<Exclude<keyof I["pagination"]["limit"], keyof Long.Long>, never>);
			countTotal?: boolean;
			reverse?: boolean;
		} & Record<Exclude<keyof I["pagination"], keyof PageRequest>, never>;
	} & Record<Exclude<keyof I, "pagination">, never>>(object: I): QueryTotalSupplyRequest;
};
declare const QueryTotalSupplyResponse: {
	encode(message: QueryTotalSupplyResponse, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryTotalSupplyResponse;
	fromJSON(object: any): QueryTotalSupplyResponse;
	toJSON(message: QueryTotalSupplyResponse): unknown;
	fromPartial<I extends {
		supply?: {
			denom?: string;
			amount?: string;
		}[];
		pagination?: {
			nextKey?: Uint8Array;
			total?: string | number | Long.Long;
		};
	} & {
		supply?: {
			denom?: string;
			amount?: string;
		}[] & ({
			denom?: string;
			amount?: string;
		} & {
			denom?: string;
			amount?: string;
		} & Record<Exclude<keyof I["supply"][number], keyof Coin>, never>)[] & Record<Exclude<keyof I["supply"], keyof {
			denom?: string;
			amount?: string;
		}[]>, never>;
		pagination?: {
			nextKey?: Uint8Array;
			total?: string | number | Long.Long;
		} & {
			nextKey?: Uint8Array;
			total?: string | number | (Long.Long & {
				high: number;
				low: number;
				unsigned: boolean;
				add: (addend: string | number | Long.Long) => Long.Long;
				and: (other: string | number | Long.Long) => Long.Long;
				compare: (other: string | number | Long.Long) => number;
				comp: (other: string | number | Long.Long) => number;
				divide: (divisor: string | number | Long.Long) => Long.Long;
				div: (divisor: string | number | Long.Long) => Long.Long;
				equals: (other: string | number | Long.Long) => boolean;
				eq: (other: string | number | Long.Long) => boolean;
				getHighBits: () => number;
				getHighBitsUnsigned: () => number;
				getLowBits: () => number;
				getLowBitsUnsigned: () => number;
				getNumBitsAbs: () => number;
				greaterThan: (other: string | number | Long.Long) => boolean;
				gt: (other: string | number | Long.Long) => boolean;
				greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
				gte: (other: string | number | Long.Long) => boolean;
				isEven: () => boolean;
				isNegative: () => boolean;
				isOdd: () => boolean;
				isPositive: () => boolean;
				isZero: () => boolean;
				lessThan: (other: string | number | Long.Long) => boolean;
				lt: (other: string | number | Long.Long) => boolean;
				lessThanOrEqual: (other: string | number | Long.Long) => boolean;
				lte: (other: string | number | Long.Long) => boolean;
				modulo: (other: string | number | Long.Long) => Long.Long;
				mod: (other: string | number | Long.Long) => Long.Long;
				multiply: (multiplier: string | number | Long.Long) => Long.Long;
				mul: (multiplier: string | number | Long.Long) => Long.Long;
				negate: () => Long.Long;
				neg: () => Long.Long;
				not: () => Long.Long;
				notEquals: (other: string | number | Long.Long) => boolean;
				neq: (other: string | number | Long.Long) => boolean;
				or: (other: string | number | Long.Long) => Long.Long;
				shiftLeft: (numBits: number | Long.Long) => Long.Long;
				shl: (numBits: number | Long.Long) => Long.Long;
				shiftRight: (numBits: number | Long.Long) => Long.Long;
				shr: (numBits: number | Long.Long) => Long.Long;
				shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
				shru: (numBits: number | Long.Long) => Long.Long;
				subtract: (subtrahend: string | number | Long.Long) => Long.Long;
				sub: (subtrahend: string | number | Long.Long) => Long.Long;
				toInt: () => number;
				toNumber: () => number;
				toBytes: (le?: boolean) => number[];
				toBytesLE: () => number[];
				toBytesBE: () => number[];
				toSigned: () => Long.Long;
				toString: (radix?: number) => string;
				toUnsigned: () => Long.Long;
				xor: (other: string | number | Long.Long) => Long.Long;
			} & Record<Exclude<keyof I["pagination"]["total"], keyof Long.Long>, never>);
		} & Record<Exclude<keyof I["pagination"], keyof PageResponse>, never>;
	} & Record<Exclude<keyof I, keyof QueryTotalSupplyResponse>, never>>(object: I): QueryTotalSupplyResponse;
};
declare const QuerySupplyOfRequest: {
	encode(message: QuerySupplyOfRequest, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QuerySupplyOfRequest;
	fromJSON(object: any): QuerySupplyOfRequest;
	toJSON(message: QuerySupplyOfRequest): unknown;
	fromPartial<I extends {
		denom?: string;
	} & {
		denom?: string;
	} & Record<Exclude<keyof I, "denom">, never>>(object: I): QuerySupplyOfRequest;
};
declare const QuerySupplyOfResponse: {
	encode(message: QuerySupplyOfResponse, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QuerySupplyOfResponse;
	fromJSON(object: any): QuerySupplyOfResponse;
	toJSON(message: QuerySupplyOfResponse): unknown;
	fromPartial<I extends {
		amount?: {
			denom?: string;
			amount?: string;
		};
	} & {
		amount?: {
			denom?: string;
			amount?: string;
		} & {
			denom?: string;
			amount?: string;
		} & Record<Exclude<keyof I["amount"], keyof Coin>, never>;
	} & Record<Exclude<keyof I, "amount">, never>>(object: I): QuerySupplyOfResponse;
};
declare const QueryParamsRequest: {
	encode(_: QueryParamsRequest, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryParamsRequest;
	fromJSON(_: any): QueryParamsRequest;
	toJSON(_: QueryParamsRequest): unknown;
	fromPartial<I extends {} & {} & Record<Exclude<keyof I, never>, never>>(_: I): QueryParamsRequest;
};
declare const QueryParamsResponse: {
	encode(message: QueryParamsResponse, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryParamsResponse;
	fromJSON(object: any): QueryParamsResponse;
	toJSON(message: QueryParamsResponse): unknown;
	fromPartial<I extends {
		params?: {
			sendEnabled?: {
				denom?: string;
				enabled?: boolean;
			}[];
			defaultSendEnabled?: boolean;
		};
	} & {
		params?: {
			sendEnabled?: {
				denom?: string;
				enabled?: boolean;
			}[];
			defaultSendEnabled?: boolean;
		} & {
			sendEnabled?: {
				denom?: string;
				enabled?: boolean;
			}[] & ({
				denom?: string;
				enabled?: boolean;
			} & {
				denom?: string;
				enabled?: boolean;
			} & Record<Exclude<keyof I["params"]["sendEnabled"][number], keyof SendEnabled>, never>)[] & Record<Exclude<keyof I["params"]["sendEnabled"], keyof {
				denom?: string;
				enabled?: boolean;
			}[]>, never>;
			defaultSendEnabled?: boolean;
		} & Record<Exclude<keyof I["params"], keyof Params>, never>;
	} & Record<Exclude<keyof I, "params">, never>>(object: I): QueryParamsResponse;
};
declare const QueryDenomsMetadataRequest: {
	encode(message: QueryDenomsMetadataRequest, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryDenomsMetadataRequest;
	fromJSON(object: any): QueryDenomsMetadataRequest;
	toJSON(message: QueryDenomsMetadataRequest): unknown;
	fromPartial<I extends {
		pagination?: {
			key?: Uint8Array;
			offset?: string | number | Long.Long;
			limit?: string | number | Long.Long;
			countTotal?: boolean;
			reverse?: boolean;
		};
	} & {
		pagination?: {
			key?: Uint8Array;
			offset?: string | number | Long.Long;
			limit?: string | number | Long.Long;
			countTotal?: boolean;
			reverse?: boolean;
		} & {
			key?: Uint8Array;
			offset?: string | number | (Long.Long & {
				high: number;
				low: number;
				unsigned: boolean;
				add: (addend: string | number | Long.Long) => Long.Long;
				and: (other: string | number | Long.Long) => Long.Long;
				compare: (other: string | number | Long.Long) => number;
				comp: (other: string | number | Long.Long) => number;
				divide: (divisor: string | number | Long.Long) => Long.Long;
				div: (divisor: string | number | Long.Long) => Long.Long;
				equals: (other: string | number | Long.Long) => boolean;
				eq: (other: string | number | Long.Long) => boolean;
				getHighBits: () => number;
				getHighBitsUnsigned: () => number;
				getLowBits: () => number;
				getLowBitsUnsigned: () => number;
				getNumBitsAbs: () => number;
				greaterThan: (other: string | number | Long.Long) => boolean;
				gt: (other: string | number | Long.Long) => boolean;
				greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
				gte: (other: string | number | Long.Long) => boolean;
				isEven: () => boolean;
				isNegative: () => boolean;
				isOdd: () => boolean;
				isPositive: () => boolean;
				isZero: () => boolean;
				lessThan: (other: string | number | Long.Long) => boolean;
				lt: (other: string | number | Long.Long) => boolean;
				lessThanOrEqual: (other: string | number | Long.Long) => boolean;
				lte: (other: string | number | Long.Long) => boolean;
				modulo: (other: string | number | Long.Long) => Long.Long;
				mod: (other: string | number | Long.Long) => Long.Long;
				multiply: (multiplier: string | number | Long.Long) => Long.Long;
				mul: (multiplier: string | number | Long.Long) => Long.Long;
				negate: () => Long.Long;
				neg: () => Long.Long;
				not: () => Long.Long;
				notEquals: (other: string | number | Long.Long) => boolean;
				neq: (other: string | number | Long.Long) => boolean;
				or: (other: string | number | Long.Long) => Long.Long;
				shiftLeft: (numBits: number | Long.Long) => Long.Long;
				shl: (numBits: number | Long.Long) => Long.Long;
				shiftRight: (numBits: number | Long.Long) => Long.Long;
				shr: (numBits: number | Long.Long) => Long.Long;
				shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
				shru: (numBits: number | Long.Long) => Long.Long;
				subtract: (subtrahend: string | number | Long.Long) => Long.Long;
				sub: (subtrahend: string | number | Long.Long) => Long.Long;
				toInt: () => number;
				toNumber: () => number;
				toBytes: (le?: boolean) => number[];
				toBytesLE: () => number[];
				toBytesBE: () => number[];
				toSigned: () => Long.Long;
				toString: (radix?: number) => string;
				toUnsigned: () => Long.Long;
				xor: (other: string | number | Long.Long) => Long.Long;
			} & Record<Exclude<keyof I["pagination"]["offset"], keyof Long.Long>, never>);
			limit?: string | number | (Long.Long & {
				high: number;
				low: number;
				unsigned: boolean;
				add: (addend: string | number | Long.Long) => Long.Long;
				and: (other: string | number | Long.Long) => Long.Long;
				compare: (other: string | number | Long.Long) => number;
				comp: (other: string | number | Long.Long) => number;
				divide: (divisor: string | number | Long.Long) => Long.Long;
				div: (divisor: string | number | Long.Long) => Long.Long;
				equals: (other: string | number | Long.Long) => boolean;
				eq: (other: string | number | Long.Long) => boolean;
				getHighBits: () => number;
				getHighBitsUnsigned: () => number;
				getLowBits: () => number;
				getLowBitsUnsigned: () => number;
				getNumBitsAbs: () => number;
				greaterThan: (other: string | number | Long.Long) => boolean;
				gt: (other: string | number | Long.Long) => boolean;
				greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
				gte: (other: string | number | Long.Long) => boolean;
				isEven: () => boolean;
				isNegative: () => boolean;
				isOdd: () => boolean;
				isPositive: () => boolean;
				isZero: () => boolean;
				lessThan: (other: string | number | Long.Long) => boolean;
				lt: (other: string | number | Long.Long) => boolean;
				lessThanOrEqual: (other: string | number | Long.Long) => boolean;
				lte: (other: string | number | Long.Long) => boolean;
				modulo: (other: string | number | Long.Long) => Long.Long;
				mod: (other: string | number | Long.Long) => Long.Long;
				multiply: (multiplier: string | number | Long.Long) => Long.Long;
				mul: (multiplier: string | number | Long.Long) => Long.Long;
				negate: () => Long.Long;
				neg: () => Long.Long;
				not: () => Long.Long;
				notEquals: (other: string | number | Long.Long) => boolean;
				neq: (other: string | number | Long.Long) => boolean;
				or: (other: string | number | Long.Long) => Long.Long;
				shiftLeft: (numBits: number | Long.Long) => Long.Long;
				shl: (numBits: number | Long.Long) => Long.Long;
				shiftRight: (numBits: number | Long.Long) => Long.Long;
				shr: (numBits: number | Long.Long) => Long.Long;
				shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
				shru: (numBits: number | Long.Long) => Long.Long;
				subtract: (subtrahend: string | number | Long.Long) => Long.Long;
				sub: (subtrahend: string | number | Long.Long) => Long.Long;
				toInt: () => number;
				toNumber: () => number;
				toBytes: (le?: boolean) => number[];
				toBytesLE: () => number[];
				toBytesBE: () => number[];
				toSigned: () => Long.Long;
				toString: (radix?: number) => string;
				toUnsigned: () => Long.Long;
				xor: (other: string | number | Long.Long) => Long.Long;
			} & Record<Exclude<keyof I["pagination"]["limit"], keyof Long.Long>, never>);
			countTotal?: boolean;
			reverse?: boolean;
		} & Record<Exclude<keyof I["pagination"], keyof PageRequest>, never>;
	} & Record<Exclude<keyof I, "pagination">, never>>(object: I): QueryDenomsMetadataRequest;
};
declare const QueryDenomsMetadataResponse: {
	encode(message: QueryDenomsMetadataResponse, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryDenomsMetadataResponse;
	fromJSON(object: any): QueryDenomsMetadataResponse;
	toJSON(message: QueryDenomsMetadataResponse): unknown;
	fromPartial<I extends {
		metadatas?: {
			description?: string;
			denomUnits?: {
				denom?: string;
				exponent?: number;
				aliases?: string[];
			}[];
			base?: string;
			display?: string;
			name?: string;
			symbol?: string;
		}[];
		pagination?: {
			nextKey?: Uint8Array;
			total?: string | number | Long.Long;
		};
	} & {
		metadatas?: {
			description?: string;
			denomUnits?: {
				denom?: string;
				exponent?: number;
				aliases?: string[];
			}[];
			base?: string;
			display?: string;
			name?: string;
			symbol?: string;
		}[] & ({
			description?: string;
			denomUnits?: {
				denom?: string;
				exponent?: number;
				aliases?: string[];
			}[];
			base?: string;
			display?: string;
			name?: string;
			symbol?: string;
		} & {
			description?: string;
			denomUnits?: {
				denom?: string;
				exponent?: number;
				aliases?: string[];
			}[] & ({
				denom?: string;
				exponent?: number;
				aliases?: string[];
			} & {
				denom?: string;
				exponent?: number;
				aliases?: string[] & string[] & Record<Exclude<keyof I["metadatas"][number]["denomUnits"][number]["aliases"], keyof string[]>, never>;
			} & Record<Exclude<keyof I["metadatas"][number]["denomUnits"][number], keyof DenomUnit>, never>)[] & Record<Exclude<keyof I["metadatas"][number]["denomUnits"], keyof {
				denom?: string;
				exponent?: number;
				aliases?: string[];
			}[]>, never>;
			base?: string;
			display?: string;
			name?: string;
			symbol?: string;
		} & Record<Exclude<keyof I["metadatas"][number], keyof Metadata>, never>)[] & Record<Exclude<keyof I["metadatas"], keyof {
			description?: string;
			denomUnits?: {
				denom?: string;
				exponent?: number;
				aliases?: string[];
			}[];
			base?: string;
			display?: string;
			name?: string;
			symbol?: string;
		}[]>, never>;
		pagination?: {
			nextKey?: Uint8Array;
			total?: string | number | Long.Long;
		} & {
			nextKey?: Uint8Array;
			total?: string | number | (Long.Long & {
				high: number;
				low: number;
				unsigned: boolean;
				add: (addend: string | number | Long.Long) => Long.Long;
				and: (other: string | number | Long.Long) => Long.Long;
				compare: (other: string | number | Long.Long) => number;
				comp: (other: string | number | Long.Long) => number;
				divide: (divisor: string | number | Long.Long) => Long.Long;
				div: (divisor: string | number | Long.Long) => Long.Long;
				equals: (other: string | number | Long.Long) => boolean;
				eq: (other: string | number | Long.Long) => boolean;
				getHighBits: () => number;
				getHighBitsUnsigned: () => number;
				getLowBits: () => number;
				getLowBitsUnsigned: () => number;
				getNumBitsAbs: () => number;
				greaterThan: (other: string | number | Long.Long) => boolean;
				gt: (other: string | number | Long.Long) => boolean;
				greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
				gte: (other: string | number | Long.Long) => boolean;
				isEven: () => boolean;
				isNegative: () => boolean;
				isOdd: () => boolean;
				isPositive: () => boolean;
				isZero: () => boolean;
				lessThan: (other: string | number | Long.Long) => boolean;
				lt: (other: string | number | Long.Long) => boolean;
				lessThanOrEqual: (other: string | number | Long.Long) => boolean;
				lte: (other: string | number | Long.Long) => boolean;
				modulo: (other: string | number | Long.Long) => Long.Long;
				mod: (other: string | number | Long.Long) => Long.Long;
				multiply: (multiplier: string | number | Long.Long) => Long.Long;
				mul: (multiplier: string | number | Long.Long) => Long.Long;
				negate: () => Long.Long;
				neg: () => Long.Long;
				not: () => Long.Long;
				notEquals: (other: string | number | Long.Long) => boolean;
				neq: (other: string | number | Long.Long) => boolean;
				or: (other: string | number | Long.Long) => Long.Long;
				shiftLeft: (numBits: number | Long.Long) => Long.Long;
				shl: (numBits: number | Long.Long) => Long.Long;
				shiftRight: (numBits: number | Long.Long) => Long.Long;
				shr: (numBits: number | Long.Long) => Long.Long;
				shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
				shru: (numBits: number | Long.Long) => Long.Long;
				subtract: (subtrahend: string | number | Long.Long) => Long.Long;
				sub: (subtrahend: string | number | Long.Long) => Long.Long;
				toInt: () => number;
				toNumber: () => number;
				toBytes: (le?: boolean) => number[];
				toBytesLE: () => number[];
				toBytesBE: () => number[];
				toSigned: () => Long.Long;
				toString: (radix?: number) => string;
				toUnsigned: () => Long.Long;
				xor: (other: string | number | Long.Long) => Long.Long;
			} & Record<Exclude<keyof I["pagination"]["total"], keyof Long.Long>, never>);
		} & Record<Exclude<keyof I["pagination"], keyof PageResponse>, never>;
	} & Record<Exclude<keyof I, keyof QueryDenomsMetadataResponse>, never>>(object: I): QueryDenomsMetadataResponse;
};
declare const QueryDenomMetadataRequest: {
	encode(message: QueryDenomMetadataRequest, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryDenomMetadataRequest;
	fromJSON(object: any): QueryDenomMetadataRequest;
	toJSON(message: QueryDenomMetadataRequest): unknown;
	fromPartial<I extends {
		denom?: string;
	} & {
		denom?: string;
	} & Record<Exclude<keyof I, "denom">, never>>(object: I): QueryDenomMetadataRequest;
};
declare const QueryDenomMetadataResponse: {
	encode(message: QueryDenomMetadataResponse, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryDenomMetadataResponse;
	fromJSON(object: any): QueryDenomMetadataResponse;
	toJSON(message: QueryDenomMetadataResponse): unknown;
	fromPartial<I extends {
		metadata?: {
			description?: string;
			denomUnits?: {
				denom?: string;
				exponent?: number;
				aliases?: string[];
			}[];
			base?: string;
			display?: string;
			name?: string;
			symbol?: string;
		};
	} & {
		metadata?: {
			description?: string;
			denomUnits?: {
				denom?: string;
				exponent?: number;
				aliases?: string[];
			}[];
			base?: string;
			display?: string;
			name?: string;
			symbol?: string;
		} & {
			description?: string;
			denomUnits?: {
				denom?: string;
				exponent?: number;
				aliases?: string[];
			}[] & ({
				denom?: string;
				exponent?: number;
				aliases?: string[];
			} & {
				denom?: string;
				exponent?: number;
				aliases?: string[] & string[] & Record<Exclude<keyof I["metadata"]["denomUnits"][number]["aliases"], keyof string[]>, never>;
			} & Record<Exclude<keyof I["metadata"]["denomUnits"][number], keyof DenomUnit>, never>)[] & Record<Exclude<keyof I["metadata"]["denomUnits"], keyof {
				denom?: string;
				exponent?: number;
				aliases?: string[];
			}[]>, never>;
			base?: string;
			display?: string;
			name?: string;
			symbol?: string;
		} & Record<Exclude<keyof I["metadata"], keyof Metadata>, never>;
	} & Record<Exclude<keyof I, "metadata">, never>>(object: I): QueryDenomMetadataResponse;
};
/** Query defines the gRPC querier service. */
export interface Query {
	/** Balance queries the balance of a single coin for a single account. */
	Balance(request: QueryBalanceRequest): Promise<QueryBalanceResponse>;
	/** AllBalances queries the balance of all coins for a single account. */
	AllBalances(request: QueryAllBalancesRequest): Promise<QueryAllBalancesResponse>;
	/** TotalSupply queries the total supply of all coins. */
	TotalSupply(request: QueryTotalSupplyRequest): Promise<QueryTotalSupplyResponse>;
	/** SupplyOf queries the supply of a single coin. */
	SupplyOf(request: QuerySupplyOfRequest): Promise<QuerySupplyOfResponse>;
	/** Params queries the parameters of x/bank module. */
	Params(request: QueryParamsRequest): Promise<QueryParamsResponse>;
	/** DenomsMetadata queries the client metadata of a given coin denomination. */
	DenomMetadata(request: QueryDenomMetadataRequest): Promise<QueryDenomMetadataResponse>;
	/** DenomsMetadata queries the client metadata for all registered coin denominations. */
	DenomsMetadata(request: QueryDenomsMetadataRequest): Promise<QueryDenomsMetadataResponse>;
}
declare class QueryClientImpl implements Query {
	private readonly rpc;
	constructor(rpc: Rpc);
	Balance(request: QueryBalanceRequest): Promise<QueryBalanceResponse>;
	AllBalances(request: QueryAllBalancesRequest): Promise<QueryAllBalancesResponse>;
	TotalSupply(request: QueryTotalSupplyRequest): Promise<QueryTotalSupplyResponse>;
	SupplyOf(request: QuerySupplyOfRequest): Promise<QuerySupplyOfResponse>;
	Params(request: QueryParamsRequest): Promise<QueryParamsResponse>;
	DenomMetadata(request: QueryDenomMetadataRequest): Promise<QueryDenomMetadataResponse>;
	DenomsMetadata(request: QueryDenomsMetadataRequest): Promise<QueryDenomsMetadataResponse>;
}
export interface Rpc {
	request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}
/** Params defines the parameters for the module. */
export interface Params {
	testnet: string;
}
declare const Params: {
	encode(message: Params, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): Params;
	fromJSON(object: any): Params;
	toJSON(message: Params): unknown;
	fromPartial<I extends {
		testnet?: string;
	} & {
		testnet?: string;
	} & Record<Exclude<keyof I, "testnet">, never>>(object: I): Params;
};
/** QueryParamsRequest is request type for the Query/Params RPC method. */
export interface QueryParamsRequest {
}
/** QueryParamsResponse is response type for the Query/Params RPC method. */
export interface QueryParamsResponse {
	/** params holds all the parameters of this module. */
	params?: Params;
}
export interface QueryMintRequest {
	address: string;
}
export interface QueryMintResponse {
	address: string;
	mnemonic: string;
}
declare const QueryParamsRequest: {
	encode(_: QueryParamsRequest, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryParamsRequest;
	fromJSON(_: any): QueryParamsRequest;
	toJSON(_: QueryParamsRequest): unknown;
	fromPartial<I extends {} & {} & Record<Exclude<keyof I, never>, never>>(_: I): QueryParamsRequest;
};
declare const QueryParamsResponse: {
	encode(message: QueryParamsResponse, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryParamsResponse;
	fromJSON(object: any): QueryParamsResponse;
	toJSON(message: QueryParamsResponse): unknown;
	fromPartial<I extends {
		params?: {
			testnet?: string;
		};
	} & {
		params?: {
			testnet?: string;
		} & {
			testnet?: string;
		} & Record<Exclude<keyof I["params"], "testnet">, never>;
	} & Record<Exclude<keyof I, "params">, never>>(object: I): QueryParamsResponse;
};
declare const QueryMintRequest: {
	encode(message: QueryMintRequest, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryMintRequest;
	fromJSON(object: any): QueryMintRequest;
	toJSON(message: QueryMintRequest): unknown;
	fromPartial<I extends {
		address?: string;
	} & {
		address?: string;
	} & Record<Exclude<keyof I, "address">, never>>(object: I): QueryMintRequest;
};
declare const QueryMintResponse: {
	encode(message: QueryMintResponse, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryMintResponse;
	fromJSON(object: any): QueryMintResponse;
	toJSON(message: QueryMintResponse): unknown;
	fromPartial<I extends {
		address?: string;
		mnemonic?: string;
	} & {
		address?: string;
		mnemonic?: string;
	} & Record<Exclude<keyof I, keyof QueryMintResponse>, never>>(object: I): QueryMintResponse;
};
/** Query defines the gRPC querier service. */
export interface Query {
	/** Parameters queries the parameters of the module. */
	Params(request: QueryParamsRequest): Promise<QueryParamsResponse>;
	/** Queries a list of Mint items. */
	Mint(request: QueryMintRequest): Promise<QueryMintResponse>;
}
declare class QueryClientImpl implements Query {
	private readonly rpc;
	constructor(rpc: Rpc);
	Params(request: QueryParamsRequest): Promise<QueryParamsResponse>;
	Mint(request: QueryMintRequest): Promise<QueryMintResponse>;
}
export interface Rpc {
	request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}
export interface QueryGetTaxInfoRequest {
}
export interface QueryGetTaxInfoResponse {
	gasTaxBp: Long;
	transferTaxBp: Long;
	taxCollector: string;
}
declare const QueryGetTaxInfoRequest: {
	encode(_: QueryGetTaxInfoRequest, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryGetTaxInfoRequest;
	fromJSON(_: any): QueryGetTaxInfoRequest;
	toJSON(_: QueryGetTaxInfoRequest): unknown;
	fromPartial<I extends {} & {} & Record<Exclude<keyof I, never>, never>>(_: I): QueryGetTaxInfoRequest;
};
declare const QueryGetTaxInfoResponse: {
	encode(message: QueryGetTaxInfoResponse, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryGetTaxInfoResponse;
	fromJSON(object: any): QueryGetTaxInfoResponse;
	toJSON(message: QueryGetTaxInfoResponse): unknown;
	fromPartial<I extends {
		gasTaxBp?: string | number | Long.Long;
		transferTaxBp?: string | number | Long.Long;
		taxCollector?: string;
	} & {
		gasTaxBp?: string | number | (Long.Long & {
			high: number;
			low: number;
			unsigned: boolean;
			add: (addend: string | number | Long.Long) => Long.Long;
			and: (other: string | number | Long.Long) => Long.Long;
			compare: (other: string | number | Long.Long) => number;
			comp: (other: string | number | Long.Long) => number;
			divide: (divisor: string | number | Long.Long) => Long.Long;
			div: (divisor: string | number | Long.Long) => Long.Long;
			equals: (other: string | number | Long.Long) => boolean;
			eq: (other: string | number | Long.Long) => boolean;
			getHighBits: () => number;
			getHighBitsUnsigned: () => number;
			getLowBits: () => number;
			getLowBitsUnsigned: () => number;
			getNumBitsAbs: () => number;
			greaterThan: (other: string | number | Long.Long) => boolean;
			gt: (other: string | number | Long.Long) => boolean;
			greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
			gte: (other: string | number | Long.Long) => boolean;
			isEven: () => boolean;
			isNegative: () => boolean;
			isOdd: () => boolean;
			isPositive: () => boolean;
			isZero: () => boolean;
			lessThan: (other: string | number | Long.Long) => boolean;
			lt: (other: string | number | Long.Long) => boolean;
			lessThanOrEqual: (other: string | number | Long.Long) => boolean;
			lte: (other: string | number | Long.Long) => boolean;
			modulo: (other: string | number | Long.Long) => Long.Long;
			mod: (other: string | number | Long.Long) => Long.Long;
			multiply: (multiplier: string | number | Long.Long) => Long.Long;
			mul: (multiplier: string | number | Long.Long) => Long.Long;
			negate: () => Long.Long;
			neg: () => Long.Long;
			not: () => Long.Long;
			notEquals: (other: string | number | Long.Long) => boolean;
			neq: (other: string | number | Long.Long) => boolean;
			or: (other: string | number | Long.Long) => Long.Long;
			shiftLeft: (numBits: number | Long.Long) => Long.Long;
			shl: (numBits: number | Long.Long) => Long.Long;
			shiftRight: (numBits: number | Long.Long) => Long.Long;
			shr: (numBits: number | Long.Long) => Long.Long;
			shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
			shru: (numBits: number | Long.Long) => Long.Long;
			subtract: (subtrahend: string | number | Long.Long) => Long.Long;
			sub: (subtrahend: string | number | Long.Long) => Long.Long;
			toInt: () => number;
			toNumber: () => number;
			toBytes: (le?: boolean) => number[];
			toBytesLE: () => number[];
			toBytesBE: () => number[];
			toSigned: () => Long.Long;
			toString: (radix?: number) => string;
			toUnsigned: () => Long.Long;
			xor: (other: string | number | Long.Long) => Long.Long;
		} & Record<Exclude<keyof I["gasTaxBp"], keyof Long.Long>, never>);
		transferTaxBp?: string | number | (Long.Long & {
			high: number;
			low: number;
			unsigned: boolean;
			add: (addend: string | number | Long.Long) => Long.Long;
			and: (other: string | number | Long.Long) => Long.Long;
			compare: (other: string | number | Long.Long) => number;
			comp: (other: string | number | Long.Long) => number;
			divide: (divisor: string | number | Long.Long) => Long.Long;
			div: (divisor: string | number | Long.Long) => Long.Long;
			equals: (other: string | number | Long.Long) => boolean;
			eq: (other: string | number | Long.Long) => boolean;
			getHighBits: () => number;
			getHighBitsUnsigned: () => number;
			getLowBits: () => number;
			getLowBitsUnsigned: () => number;
			getNumBitsAbs: () => number;
			greaterThan: (other: string | number | Long.Long) => boolean;
			gt: (other: string | number | Long.Long) => boolean;
			greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
			gte: (other: string | number | Long.Long) => boolean;
			isEven: () => boolean;
			isNegative: () => boolean;
			isOdd: () => boolean;
			isPositive: () => boolean;
			isZero: () => boolean;
			lessThan: (other: string | number | Long.Long) => boolean;
			lt: (other: string | number | Long.Long) => boolean;
			lessThanOrEqual: (other: string | number | Long.Long) => boolean;
			lte: (other: string | number | Long.Long) => boolean;
			modulo: (other: string | number | Long.Long) => Long.Long;
			mod: (other: string | number | Long.Long) => Long.Long;
			multiply: (multiplier: string | number | Long.Long) => Long.Long;
			mul: (multiplier: string | number | Long.Long) => Long.Long;
			negate: () => Long.Long;
			neg: () => Long.Long;
			not: () => Long.Long;
			notEquals: (other: string | number | Long.Long) => boolean;
			neq: (other: string | number | Long.Long) => boolean;
			or: (other: string | number | Long.Long) => Long.Long;
			shiftLeft: (numBits: number | Long.Long) => Long.Long;
			shl: (numBits: number | Long.Long) => Long.Long;
			shiftRight: (numBits: number | Long.Long) => Long.Long;
			shr: (numBits: number | Long.Long) => Long.Long;
			shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
			shru: (numBits: number | Long.Long) => Long.Long;
			subtract: (subtrahend: string | number | Long.Long) => Long.Long;
			sub: (subtrahend: string | number | Long.Long) => Long.Long;
			toInt: () => number;
			toNumber: () => number;
			toBytes: (le?: boolean) => number[];
			toBytesLE: () => number[];
			toBytesBE: () => number[];
			toSigned: () => Long.Long;
			toString: (radix?: number) => string;
			toUnsigned: () => Long.Long;
			xor: (other: string | number | Long.Long) => Long.Long;
		} & Record<Exclude<keyof I["transferTaxBp"], keyof Long.Long>, never>);
		taxCollector?: string;
	} & Record<Exclude<keyof I, keyof QueryGetTaxInfoResponse>, never>>(object: I): QueryGetTaxInfoResponse;
};
/** Query defines the gRPC querier service. */
export interface Query {
	/** Queries a list of GetTaxInfo items. */
	GetTaxInfo(request: QueryGetTaxInfoRequest): Promise<QueryGetTaxInfoResponse>;
}
declare class QueryClientImpl implements Query {
	private readonly rpc;
	constructor(rpc: Rpc);
	GetTaxInfo(request: QueryGetTaxInfoRequest): Promise<QueryGetTaxInfoResponse>;
}
export interface Rpc {
	request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}
export declare type QueryClientImpl = {
	storage: StorageQueryClientImpl;
	bank: BankQueryClientImpl;
	faucet: FaucetQueryClientImpl;
	tax: TaxQueryClientImpl;
};
export interface BluzelleClient {
	url: string;
	address: string;
	sgClient: SigningStargateClient;
	queryClient: QueryClientImpl;
	tmClient: Tendermint34Client;
}
export declare const newBluzelleClient: (config: {
	wallet: () => Promise<BluzelleWallet>;
	url: string;
}) => Promise<BluzelleClient>;
declare class SigningBluzelleClient extends SigningStargateClient {
	private wallet;
	protected constructor(tmClient: Tendermint34Client | undefined, signer: BluzelleWallet, options: SigningStargateClientOptions);
	getSequenceFromNetwork(address: string): Promise<SequenceResponse>;
	getSequence(address: string): Promise<SequenceResponse>;
	static connectWithSigner(endpoint: string, signer: BluzelleWallet, options?: {}): Promise<SigningBluzelleClient>;
}
export interface BluzelleWallet extends OfflineDirectSigner {
	getSequence: (client: SigningBluzelleClient, signerAddress: string) => Promise<SequenceResponse>;
}
export interface LocalWalletOptions {
	coinType?: number;
	index?: number;
}
export declare const newLocalWallet: (mnemonic: string, options?: LocalWalletOptions) => () => Promise<BluzelleWallet>;
export declare type AccountAddress = string;
export declare class BluzelleLocalWallet extends DirectSecp256k1HdWallet implements BluzelleWallet {
	sequenceTable: Record<AccountAddress, SequenceResponse>;
	getSequenceQueue: Promise<SequenceResponse>;
	static fromMnemonic(mnemonic: string, options?: Partial<DirectSecp256k1HdWalletOptions>): Promise<BluzelleLocalWallet>;
	getSequence(client: SigningBluzelleClient, signerAddress: string): Promise<SequenceResponse>;
}
export interface SignDoc {
	bodyBytes: Uint8Array;
	authInfoBytes: Uint8Array;
	chainId: string;
	accountNumber: Long;
}
export declare const newKeplrWallet: (nodeAddress: string) => () => Promise<BluzelleWallet>;
export declare type AccountAddress = string;
export declare class BluzelleKeplrWallet implements BluzelleWallet {
	getAccounts: () => Promise<readonly AccountData[]>;
	signDirect: (signerAddress: string, signDoc: SignDoc) => Promise<DirectSignResponse>;
	constructor(keplrOfflineSigner: OfflineDirectSigner);
	sequenceTable: Record<AccountAddress, SequenceResponse>;
	getSequenceQueue: Promise<SequenceResponse>;
	getSequence(client: SigningBluzelleClient, signerAddress: string): Promise<SequenceResponse>;
}
export declare function createAddress(): Promise<{
	mnemonic: string;
	address: string;
}>;
export declare function mint(client: BluzelleClient, address?: string): Promise<{
	mnemonic: string;
	address: string;
}>;
export declare const hasContent: (client: BluzelleClient, cid: string) => Promise<boolean>;
export declare const getAccountBalance: (client: BluzelleClient, address: string) => Promise<number>;
export declare const getTaxInfo: (client: BluzelleClient) => Promise<QueryGetTaxInfoResponse>;
export interface NodeStatusResponse {
	nodeId: string;
	chainId: string;
	moniker: string;
	blockHeight: number;
	caughtUp: boolean;
}
export interface ValidatorResponse {
	address: string;
	votingPower: number;
}
export declare const getStatus: (client: BluzelleClient) => Promise<NodeStatusResponse>;
export declare const getValidators: (client: BluzelleClient) => Promise<ValidatorResponse[]>;
export declare const withTransaction: (client: BluzelleClient, fn: () => unknown) => Promise<DeliverTxResponse>;
export interface BroadcastOptions {
	gasPrice: number;
	maxGas: number;
	memo?: string;
}
export declare const pinCid: (client: BluzelleClient, cid: string, options: BroadcastOptions) => undefined;
export declare const send: (client: BluzelleClient, toAddress: string, amount: number, options: BroadcastOptions) => undefined;

export {};
