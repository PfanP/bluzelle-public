// Generated by dts-bundle-generator v6.9.0

import { DirectSecp256k1HdWallet } from '@cosmjs/proto-signing';
import { DirectSecp256k1HdWalletOptions } from '@cosmjs/proto-signing/build/directsecp256k1hdwallet';
import { AccountData, DirectSignResponse, OfflineDirectSigner } from '@cosmjs/proto-signing/build/signer';
import { SequenceResponse, SigningStargateClient } from '@cosmjs/stargate';
import { SigningStargateClientOptions } from '@cosmjs/stargate/build/signingstargateclient';
import { Tendermint34Client } from '@cosmjs/tendermint-rpc';
import { Reader, Writer } from 'protobufjs/minimal';

export interface QueryHasContentRequest {
	cid: string;
}
export interface QueryHasContentResponse {
	hasContent: boolean;
}
declare const QueryHasContentRequest: {
	encode(message: QueryHasContentRequest, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): QueryHasContentRequest;
	fromJSON(object: any): QueryHasContentRequest;
	toJSON(message: QueryHasContentRequest): unknown;
	fromPartial(object: DeepPartial<QueryHasContentRequest>): QueryHasContentRequest;
};
declare const QueryHasContentResponse: {
	encode(message: QueryHasContentResponse, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): QueryHasContentResponse;
	fromJSON(object: any): QueryHasContentResponse;
	toJSON(message: QueryHasContentResponse): unknown;
	fromPartial(object: DeepPartial<QueryHasContentResponse>): QueryHasContentResponse;
};
/** Query defines the gRPC querier service. */
export interface Query {
	HasContent(request: QueryHasContentRequest): Promise<QueryHasContentResponse>;
}
declare class QueryClientImpl implements Query {
	private readonly rpc;
	constructor(rpc: Rpc);
	HasContent(request: QueryHasContentRequest): Promise<QueryHasContentResponse>;
}
export interface Rpc {
	request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}
export declare type Builtin = Date | Function | Uint8Array | string | number | undefined;
export declare type DeepPartial<T> = T extends Builtin ? T : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {} ? {
	[K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
/**
 * Coin defines a token with a denomination and an amount.
 *
 * NOTE: The amount field is an Int which implements the custom method
 * signatures required by gogoproto.
 */
export interface Coin {
	denom: string;
	amount: string;
}
declare const Coin: {
	encode(message: Coin, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): Coin;
	fromJSON(object: any): Coin;
	toJSON(message: Coin): unknown;
	fromPartial(object: DeepPartial<Coin>): Coin;
};
export declare type Builtin = Date | Function | Uint8Array | string | number | undefined;
export declare type DeepPartial<T> = T extends Builtin ? T : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {} ? {
	[K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
/**
 * PageRequest is to be embedded in gRPC request messages for efficient
 * pagination. Ex:
 *
 *  message SomeRequest {
 *          Foo some_parameter = 1;
 *          PageRequest pagination = 2;
 *  }
 */
export interface PageRequest {
	/**
	 * key is a value returned in PageResponse.next_key to begin
	 * querying the next page most efficiently. Only one of offset or key
	 * should be set.
	 */
	key: Uint8Array;
	/**
	 * offset is a numeric offset that can be used when key is unavailable.
	 * It is less efficient than using key. Only one of offset or key should
	 * be set.
	 */
	offset: number;
	/**
	 * limit is the total number of results to be returned in the result page.
	 * If left empty it will default to a value to be set by each app.
	 */
	limit: number;
	/**
	 * count_total is set to true  to indicate that the result set should include
	 * a count of the total number of items available for pagination in UIs.
	 * count_total is only respected when offset is used. It is ignored when key
	 * is set.
	 */
	count_total: boolean;
	/** reverse is set to true if results are to be returned in the descending order. */
	reverse: boolean;
}
/**
 * PageResponse is to be embedded in gRPC response messages where the
 * corresponding request message has used PageRequest.
 *
 *  message SomeResponse {
 *          repeated Bar results = 1;
 *          PageResponse page = 2;
 *  }
 */
export interface PageResponse {
	/**
	 * next_key is the key to be passed to PageRequest.key to
	 * query the next page most efficiently
	 */
	next_key: Uint8Array;
	/**
	 * total is total number of results available if PageRequest.count_total
	 * was set, its value is undefined otherwise
	 */
	total: number;
}
declare const PageRequest: {
	encode(message: PageRequest, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): PageRequest;
	fromJSON(object: any): PageRequest;
	toJSON(message: PageRequest): unknown;
	fromPartial(object: DeepPartial<PageRequest>): PageRequest;
};
declare const PageResponse: {
	encode(message: PageResponse, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): PageResponse;
	fromJSON(object: any): PageResponse;
	toJSON(message: PageResponse): unknown;
	fromPartial(object: DeepPartial<PageResponse>): PageResponse;
};
export declare type Builtin = Date | Function | Uint8Array | string | number | undefined;
export declare type DeepPartial<T> = T extends Builtin ? T : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {} ? {
	[K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
/** Params defines the parameters for the bank module. */
export interface Params {
	send_enabled: SendEnabled[];
	default_send_enabled: boolean;
}
/**
 * SendEnabled maps coin denom to a send_enabled status (whether a denom is
 * sendable).
 */
export interface SendEnabled {
	denom: string;
	enabled: boolean;
}
/**
 * DenomUnit represents a struct that describes a given
 * denomination unit of the basic token.
 */
export interface DenomUnit {
	/** denom represents the string name of the given denom unit (e.g uatom). */
	denom: string;
	/**
	 * exponent represents power of 10 exponent that one must
	 * raise the base_denom to in order to equal the given DenomUnit's denom
	 * 1 denom = 1^exponent base_denom
	 * (e.g. with a base_denom of uatom, one can create a DenomUnit of 'atom' with
	 * exponent = 6, thus: 1 atom = 10^6 uatom).
	 */
	exponent: number;
	/** aliases is a list of string aliases for the given denom */
	aliases: string[];
}
/**
 * Metadata represents a struct that describes
 * a basic token.
 */
export interface Metadata {
	description: string;
	/** denom_units represents the list of DenomUnit's for a given coin */
	denom_units: DenomUnit[];
	/** base represents the base denom (should be the DenomUnit with exponent = 0). */
	base: string;
	/**
	 * display indicates the suggested denom that should be
	 * displayed in clients.
	 */
	display: string;
	/** name defines the name of the token (eg: Cosmos Atom) */
	name: string;
	/**
	 * symbol is the token symbol usually shown on exchanges (eg: ATOM). This can
	 * be the same as the display.
	 */
	symbol: string;
}
declare const Params: {
	encode(message: Params, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): Params;
	fromJSON(object: any): Params;
	toJSON(message: Params): unknown;
	fromPartial(object: DeepPartial<Params>): Params;
};
declare const SendEnabled: {
	encode(message: SendEnabled, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): SendEnabled;
	fromJSON(object: any): SendEnabled;
	toJSON(message: SendEnabled): unknown;
	fromPartial(object: DeepPartial<SendEnabled>): SendEnabled;
};
declare const DenomUnit: {
	encode(message: DenomUnit, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): DenomUnit;
	fromJSON(object: any): DenomUnit;
	toJSON(message: DenomUnit): unknown;
	fromPartial(object: DeepPartial<DenomUnit>): DenomUnit;
};
declare const Metadata: {
	encode(message: Metadata, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): Metadata;
	fromJSON(object: any): Metadata;
	toJSON(message: Metadata): unknown;
	fromPartial(object: DeepPartial<Metadata>): Metadata;
};
export declare type Builtin = Date | Function | Uint8Array | string | number | undefined;
export declare type DeepPartial<T> = T extends Builtin ? T : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {} ? {
	[K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
/** QueryBalanceRequest is the request type for the Query/Balance RPC method. */
export interface QueryBalanceRequest {
	/** address is the address to query balances for. */
	address: string;
	/** denom is the coin denom to query balances for. */
	denom: string;
}
/** QueryBalanceResponse is the response type for the Query/Balance RPC method. */
export interface QueryBalanceResponse {
	/** balance is the balance of the coin. */
	balance: Coin | undefined;
}
/** QueryBalanceRequest is the request type for the Query/AllBalances RPC method. */
export interface QueryAllBalancesRequest {
	/** address is the address to query balances for. */
	address: string;
	/** pagination defines an optional pagination for the request. */
	pagination: PageRequest | undefined;
}
/**
 * QueryAllBalancesResponse is the response type for the Query/AllBalances RPC
 * method.
 */
export interface QueryAllBalancesResponse {
	/** balances is the balances of all the coins. */
	balances: Coin[];
	/** pagination defines the pagination in the response. */
	pagination: PageResponse | undefined;
}
/**
 * QueryTotalSupplyRequest is the request type for the Query/TotalSupply RPC
 * method.
 */
export interface QueryTotalSupplyRequest {
	/** pagination defines an optional pagination for the request. */
	pagination: PageRequest | undefined;
}
/**
 * QueryTotalSupplyResponse is the response type for the Query/TotalSupply RPC
 * method
 */
export interface QueryTotalSupplyResponse {
	/** supply is the supply of the coins */
	supply: Coin[];
	/** pagination defines the pagination in the response. */
	pagination: PageResponse | undefined;
}
/** QuerySupplyOfRequest is the request type for the Query/SupplyOf RPC method. */
export interface QuerySupplyOfRequest {
	/** denom is the coin denom to query balances for. */
	denom: string;
}
/** QuerySupplyOfResponse is the response type for the Query/SupplyOf RPC method. */
export interface QuerySupplyOfResponse {
	/** amount is the supply of the coin. */
	amount: Coin | undefined;
}
/** QueryParamsRequest defines the request type for querying x/bank parameters. */
export interface QueryParamsRequest {
}
/** QueryParamsResponse defines the response type for querying x/bank parameters. */
export interface QueryParamsResponse {
	params: Params | undefined;
}
/** QueryDenomsMetadataRequest is the request type for the Query/DenomsMetadata RPC method. */
export interface QueryDenomsMetadataRequest {
	/** pagination defines an optional pagination for the request. */
	pagination: PageRequest | undefined;
}
/**
 * QueryDenomsMetadataResponse is the response type for the Query/DenomsMetadata RPC
 * method.
 */
export interface QueryDenomsMetadataResponse {
	/** metadata provides the client information for all the registered tokens. */
	metadatas: Metadata[];
	/** pagination defines the pagination in the response. */
	pagination: PageResponse | undefined;
}
/** QueryDenomMetadataRequest is the request type for the Query/DenomMetadata RPC method. */
export interface QueryDenomMetadataRequest {
	/** denom is the coin denom to query the metadata for. */
	denom: string;
}
/**
 * QueryDenomMetadataResponse is the response type for the Query/DenomMetadata RPC
 * method.
 */
export interface QueryDenomMetadataResponse {
	/** metadata describes and provides all the client information for the requested token. */
	metadata: Metadata | undefined;
}
declare const QueryBalanceRequest: {
	encode(message: QueryBalanceRequest, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): QueryBalanceRequest;
	fromJSON(object: any): QueryBalanceRequest;
	toJSON(message: QueryBalanceRequest): unknown;
	fromPartial(object: DeepPartial<QueryBalanceRequest>): QueryBalanceRequest;
};
declare const QueryBalanceResponse: {
	encode(message: QueryBalanceResponse, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): QueryBalanceResponse;
	fromJSON(object: any): QueryBalanceResponse;
	toJSON(message: QueryBalanceResponse): unknown;
	fromPartial(object: DeepPartial<QueryBalanceResponse>): QueryBalanceResponse;
};
declare const QueryAllBalancesRequest: {
	encode(message: QueryAllBalancesRequest, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): QueryAllBalancesRequest;
	fromJSON(object: any): QueryAllBalancesRequest;
	toJSON(message: QueryAllBalancesRequest): unknown;
	fromPartial(object: DeepPartial<QueryAllBalancesRequest>): QueryAllBalancesRequest;
};
declare const QueryAllBalancesResponse: {
	encode(message: QueryAllBalancesResponse, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): QueryAllBalancesResponse;
	fromJSON(object: any): QueryAllBalancesResponse;
	toJSON(message: QueryAllBalancesResponse): unknown;
	fromPartial(object: DeepPartial<QueryAllBalancesResponse>): QueryAllBalancesResponse;
};
declare const QueryTotalSupplyRequest: {
	encode(message: QueryTotalSupplyRequest, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): QueryTotalSupplyRequest;
	fromJSON(object: any): QueryTotalSupplyRequest;
	toJSON(message: QueryTotalSupplyRequest): unknown;
	fromPartial(object: DeepPartial<QueryTotalSupplyRequest>): QueryTotalSupplyRequest;
};
declare const QueryTotalSupplyResponse: {
	encode(message: QueryTotalSupplyResponse, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): QueryTotalSupplyResponse;
	fromJSON(object: any): QueryTotalSupplyResponse;
	toJSON(message: QueryTotalSupplyResponse): unknown;
	fromPartial(object: DeepPartial<QueryTotalSupplyResponse>): QueryTotalSupplyResponse;
};
declare const QuerySupplyOfRequest: {
	encode(message: QuerySupplyOfRequest, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): QuerySupplyOfRequest;
	fromJSON(object: any): QuerySupplyOfRequest;
	toJSON(message: QuerySupplyOfRequest): unknown;
	fromPartial(object: DeepPartial<QuerySupplyOfRequest>): QuerySupplyOfRequest;
};
declare const QuerySupplyOfResponse: {
	encode(message: QuerySupplyOfResponse, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): QuerySupplyOfResponse;
	fromJSON(object: any): QuerySupplyOfResponse;
	toJSON(message: QuerySupplyOfResponse): unknown;
	fromPartial(object: DeepPartial<QuerySupplyOfResponse>): QuerySupplyOfResponse;
};
declare const QueryParamsRequest: {
	encode(_: QueryParamsRequest, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): QueryParamsRequest;
	fromJSON(_: any): QueryParamsRequest;
	toJSON(_: QueryParamsRequest): unknown;
	fromPartial(_: DeepPartial<QueryParamsRequest>): QueryParamsRequest;
};
declare const QueryParamsResponse: {
	encode(message: QueryParamsResponse, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): QueryParamsResponse;
	fromJSON(object: any): QueryParamsResponse;
	toJSON(message: QueryParamsResponse): unknown;
	fromPartial(object: DeepPartial<QueryParamsResponse>): QueryParamsResponse;
};
declare const QueryDenomsMetadataRequest: {
	encode(message: QueryDenomsMetadataRequest, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): QueryDenomsMetadataRequest;
	fromJSON(object: any): QueryDenomsMetadataRequest;
	toJSON(message: QueryDenomsMetadataRequest): unknown;
	fromPartial(object: DeepPartial<QueryDenomsMetadataRequest>): QueryDenomsMetadataRequest;
};
declare const QueryDenomsMetadataResponse: {
	encode(message: QueryDenomsMetadataResponse, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): QueryDenomsMetadataResponse;
	fromJSON(object: any): QueryDenomsMetadataResponse;
	toJSON(message: QueryDenomsMetadataResponse): unknown;
	fromPartial(object: DeepPartial<QueryDenomsMetadataResponse>): QueryDenomsMetadataResponse;
};
declare const QueryDenomMetadataRequest: {
	encode(message: QueryDenomMetadataRequest, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): QueryDenomMetadataRequest;
	fromJSON(object: any): QueryDenomMetadataRequest;
	toJSON(message: QueryDenomMetadataRequest): unknown;
	fromPartial(object: DeepPartial<QueryDenomMetadataRequest>): QueryDenomMetadataRequest;
};
declare const QueryDenomMetadataResponse: {
	encode(message: QueryDenomMetadataResponse, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): QueryDenomMetadataResponse;
	fromJSON(object: any): QueryDenomMetadataResponse;
	toJSON(message: QueryDenomMetadataResponse): unknown;
	fromPartial(object: DeepPartial<QueryDenomMetadataResponse>): QueryDenomMetadataResponse;
};
/** Query defines the gRPC querier service. */
export interface Query {
	/** Balance queries the balance of a single coin for a single account. */
	Balance(request: QueryBalanceRequest): Promise<QueryBalanceResponse>;
	/** AllBalances queries the balance of all coins for a single account. */
	AllBalances(request: QueryAllBalancesRequest): Promise<QueryAllBalancesResponse>;
	/** TotalSupply queries the total supply of all coins. */
	TotalSupply(request: QueryTotalSupplyRequest): Promise<QueryTotalSupplyResponse>;
	/** SupplyOf queries the supply of a single coin. */
	SupplyOf(request: QuerySupplyOfRequest): Promise<QuerySupplyOfResponse>;
	/** Params queries the parameters of x/bank module. */
	Params(request: QueryParamsRequest): Promise<QueryParamsResponse>;
	/** DenomsMetadata queries the client metadata of a given coin denomination. */
	DenomMetadata(request: QueryDenomMetadataRequest): Promise<QueryDenomMetadataResponse>;
	/** DenomsMetadata queries the client metadata for all registered coin denominations. */
	DenomsMetadata(request: QueryDenomsMetadataRequest): Promise<QueryDenomsMetadataResponse>;
}
declare class QueryClientImpl implements Query {
	private readonly rpc;
	constructor(rpc: Rpc);
	Balance(request: QueryBalanceRequest): Promise<QueryBalanceResponse>;
	AllBalances(request: QueryAllBalancesRequest): Promise<QueryAllBalancesResponse>;
	TotalSupply(request: QueryTotalSupplyRequest): Promise<QueryTotalSupplyResponse>;
	SupplyOf(request: QuerySupplyOfRequest): Promise<QuerySupplyOfResponse>;
	Params(request: QueryParamsRequest): Promise<QueryParamsResponse>;
	DenomMetadata(request: QueryDenomMetadataRequest): Promise<QueryDenomMetadataResponse>;
	DenomsMetadata(request: QueryDenomsMetadataRequest): Promise<QueryDenomsMetadataResponse>;
}
export interface Rpc {
	request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}
export declare type Builtin = Date | Function | Uint8Array | string | number | undefined;
export declare type DeepPartial<T> = T extends Builtin ? T : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {} ? {
	[K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
/** Params defines the parameters for the module. */
export interface Params {
	testnet: string;
}
declare const Params: {
	encode(message: Params, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): Params;
	fromJSON(object: any): Params;
	toJSON(message: Params): unknown;
	fromPartial(object: DeepPartial<Params>): Params;
};
export declare type Builtin = Date | Function | Uint8Array | string | number | undefined;
export declare type DeepPartial<T> = T extends Builtin ? T : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {} ? {
	[K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
/** QueryParamsRequest is request type for the Query/Params RPC method. */
export interface QueryParamsRequest {
}
/** QueryParamsResponse is response type for the Query/Params RPC method. */
export interface QueryParamsResponse {
	/** params holds all the parameters of this module. */
	params: Params | undefined;
}
export interface QueryMintRequest {
	address: string;
}
export interface QueryMintResponse {
	address: string;
	mnemonic: string;
}
declare const QueryParamsRequest: {
	encode(_: QueryParamsRequest, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): QueryParamsRequest;
	fromJSON(_: any): QueryParamsRequest;
	toJSON(_: QueryParamsRequest): unknown;
	fromPartial(_: DeepPartial<QueryParamsRequest>): QueryParamsRequest;
};
declare const QueryParamsResponse: {
	encode(message: QueryParamsResponse, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): QueryParamsResponse;
	fromJSON(object: any): QueryParamsResponse;
	toJSON(message: QueryParamsResponse): unknown;
	fromPartial(object: DeepPartial<QueryParamsResponse>): QueryParamsResponse;
};
declare const QueryMintRequest: {
	encode(message: QueryMintRequest, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): QueryMintRequest;
	fromJSON(object: any): QueryMintRequest;
	toJSON(message: QueryMintRequest): unknown;
	fromPartial(object: DeepPartial<QueryMintRequest>): QueryMintRequest;
};
declare const QueryMintResponse: {
	encode(message: QueryMintResponse, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): QueryMintResponse;
	fromJSON(object: any): QueryMintResponse;
	toJSON(message: QueryMintResponse): unknown;
	fromPartial(object: DeepPartial<QueryMintResponse>): QueryMintResponse;
};
/** Query defines the gRPC querier service. */
export interface Query {
	/** Parameters queries the parameters of the module. */
	Params(request: QueryParamsRequest): Promise<QueryParamsResponse>;
	/** Queries a list of Mint items. */
	Mint(request: QueryMintRequest): Promise<QueryMintResponse>;
}
declare class QueryClientImpl implements Query {
	private readonly rpc;
	constructor(rpc: Rpc);
	Params(request: QueryParamsRequest): Promise<QueryParamsResponse>;
	Mint(request: QueryMintRequest): Promise<QueryMintResponse>;
}
export interface Rpc {
	request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}
export declare type Builtin = Date | Function | Uint8Array | string | number | undefined;
export declare type DeepPartial<T> = T extends Builtin ? T : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {} ? {
	[K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
export interface QueryGetTaxInfoRequest {
}
export interface QueryGetTaxInfoResponse {
	gasTaxBp: number;
	transferTaxBp: number;
	taxCollector: string;
}
declare const QueryGetTaxInfoRequest: {
	encode(_: QueryGetTaxInfoRequest, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): QueryGetTaxInfoRequest;
	fromJSON(_: any): QueryGetTaxInfoRequest;
	toJSON(_: QueryGetTaxInfoRequest): unknown;
	fromPartial(_: DeepPartial<QueryGetTaxInfoRequest>): QueryGetTaxInfoRequest;
};
declare const QueryGetTaxInfoResponse: {
	encode(message: QueryGetTaxInfoResponse, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): QueryGetTaxInfoResponse;
	fromJSON(object: any): QueryGetTaxInfoResponse;
	toJSON(message: QueryGetTaxInfoResponse): unknown;
	fromPartial(object: DeepPartial<QueryGetTaxInfoResponse>): QueryGetTaxInfoResponse;
};
/** Query defines the gRPC querier service. */
export interface Query {
	/** Queries a list of GetTaxInfo items. */
	GetTaxInfo(request: QueryGetTaxInfoRequest): Promise<QueryGetTaxInfoResponse>;
}
declare class QueryClientImpl implements Query {
	private readonly rpc;
	constructor(rpc: Rpc);
	GetTaxInfo(request: QueryGetTaxInfoRequest): Promise<QueryGetTaxInfoResponse>;
}
export interface Rpc {
	request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}
export declare type Builtin = Date | Function | Uint8Array | string | number | undefined;
export declare type DeepPartial<T> = T extends Builtin ? T : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {} ? {
	[K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
export declare type QueryClientImpl = {
	storage: StorageQueryClientImpl;
	bank: BankQueryClientImpl;
	faucet: FaucetQueryClientImpl;
	tax: TaxQueryClientImpl;
};
export interface BluzelleClient {
	url: string;
	address: string;
	sgClient: SigningStargateClient;
	queryClient: QueryClientImpl;
	tmClient: Tendermint34Client;
}
export declare const newBluzelleClient: (config: {
	wallet: () => Promise<BluzelleWallet>;
	url: string;
}) => Promise<BluzelleClient>;
declare class SigningBluzelleClient extends SigningStargateClient {
	private wallet;
	protected constructor(tmClient: Tendermint34Client | undefined, signer: BluzelleWallet, options: SigningStargateClientOptions);
	getSequenceFromNetwork(address: string): Promise<SequenceResponse>;
	getSequence(address: string): Promise<SequenceResponse>;
	static connectWithSigner(endpoint: string, signer: BluzelleWallet, options?: {}): Promise<SigningBluzelleClient>;
}
export interface BluzelleWallet extends OfflineDirectSigner {
	getSequence: (client: SigningBluzelleClient, signerAddress: string) => Promise<SequenceResponse>;
}
export interface LocalWalletOptions {
	coinType?: number;
	index?: number;
}
export declare const newLocalWallet: (mnemonic: string, options?: LocalWalletOptions) => () => Promise<BluzelleWallet>;
export declare type AccountAddress = string;
export declare class BluzelleLocalWallet extends DirectSecp256k1HdWallet implements BluzelleWallet {
	sequenceTable: Record<AccountAddress, SequenceResponse>;
	getSequenceQueue: Promise<SequenceResponse>;
	static fromMnemonic(mnemonic: string, options?: Partial<DirectSecp256k1HdWalletOptions>): Promise<BluzelleLocalWallet>;
	getSequence(client: SigningBluzelleClient, signerAddress: string): Promise<SequenceResponse>;
}
export interface SignDoc {
	bodyBytes: Uint8Array;
	authInfoBytes: Uint8Array;
	chainId: string;
	accountNumber: Long;
}
export declare const newKeplrWallet: (nodeAddress: string) => () => Promise<BluzelleWallet>;
export declare type AccountAddress = string;
export declare class BluzelleKeplrWallet implements BluzelleWallet {
	getAccounts: () => Promise<readonly AccountData[]>;
	signDirect: (signerAddress: string, signDoc: SignDoc) => Promise<DirectSignResponse>;
	constructor(keplrOfflineSigner: OfflineDirectSigner);
	sequenceTable: Record<AccountAddress, SequenceResponse>;
	getSequenceQueue: Promise<SequenceResponse>;
	getSequence(client: SigningBluzelleClient, signerAddress: string): Promise<SequenceResponse>;
}
export declare function mint(client: BluzelleClient, address?: string): Promise<{
	mnemonic: string;
	address: string;
}>;
export declare const hasContent: (client: BluzelleClient, cid: string) => Promise<boolean>;
export declare const getAccountBalance: (client: BluzelleClient, address: string) => Promise<number>;
export declare const getTaxInfo: (client: BluzelleClient) => Promise<QueryGetTaxInfoResponse>;
export interface NodeStatusResponse {
	nodeId: string;
	chainId: string;
	moniker: string;
	blockHeight: number;
	caughtUp: boolean;
}
export interface ValidatorResponse {
	address: string;
	votingPower: number;
}
export declare const getStatus: (client: BluzelleClient) => Promise<NodeStatusResponse>;
export declare const getValidators: (client: BluzelleClient) => Promise<ValidatorResponse[]>;
export interface BroadcastOptions {
	gasPrice: number;
	maxGas: number;
	memo?: string;
}
export declare const pinCid: (client: BluzelleClient, cid: string, options: BroadcastOptions) => undefined;
export declare const send: (client: BluzelleClient, toAddress: string, amount: number, options: BroadcastOptions) => undefined;

export {};
