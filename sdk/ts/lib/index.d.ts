// Generated by dts-bundle-generator v6.12.0

import { DirectSecp256k1HdWallet } from '@cosmjs/proto-signing';
import { DirectSecp256k1HdWalletOptions } from '@cosmjs/proto-signing/build/directsecp256k1hdwallet';
import { AccountData, DirectSignResponse, OfflineDirectSigner } from '@cosmjs/proto-signing/build/signer';
import { DeliverTxResponse, SequenceResponse, SigningStargateClient } from '@cosmjs/stargate';
import { SigningStargateClientOptions } from '@cosmjs/stargate/build/signingstargateclient';
import { Tendermint34Client } from '@cosmjs/tendermint-rpc';
import { Reader, Writer } from 'protobufjs/minimal';

export interface QueryHasContentRequest {
	cid: string;
}
export interface QueryHasContentResponse {
	hasContent: boolean;
}
declare const QueryHasContentRequest: {
	encode(message: QueryHasContentRequest, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryHasContentRequest;
	fromJSON(object: any): QueryHasContentRequest;
	toJSON(message: QueryHasContentRequest): unknown;
	fromPartial<I extends {
		cid?: string;
	} & {
		cid?: string;
	} & Record<Exclude<keyof I, "cid">, never>>(object: I): QueryHasContentRequest;
};
declare const QueryHasContentResponse: {
	encode(message: QueryHasContentResponse, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryHasContentResponse;
	fromJSON(object: any): QueryHasContentResponse;
	toJSON(message: QueryHasContentResponse): unknown;
	fromPartial<I extends {
		hasContent?: boolean;
	} & {
		hasContent?: boolean;
	} & Record<Exclude<keyof I, "hasContent">, never>>(object: I): QueryHasContentResponse;
};
/** Query defines the gRPC querier service. */
export interface Query {
	HasContent(request: QueryHasContentRequest): Promise<QueryHasContentResponse>;
}
declare class QueryClientImpl implements Query {
	private readonly rpc;
	constructor(rpc: Rpc);
	HasContent(request: QueryHasContentRequest): Promise<QueryHasContentResponse>;
}
export interface Rpc {
	request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}
/**
 * Coin defines a token with a denomination and an amount.
 *
 * NOTE: The amount field is an Int which implements the custom method
 * signatures required by gogoproto.
 */
export interface Coin {
	denom: string;
	amount: string;
}
declare const Coin: {
	encode(message: Coin, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): Coin;
	fromJSON(object: any): Coin;
	toJSON(message: Coin): unknown;
	fromPartial<I extends {
		denom?: string;
		amount?: string;
	} & {
		denom?: string;
		amount?: string;
	} & Record<Exclude<keyof I, keyof Coin>, never>>(object: I): Coin;
};
/**
 * PageRequest is to be embedded in gRPC request messages for efficient
 * pagination. Ex:
 *
 *  message SomeRequest {
 *          Foo some_parameter = 1;
 *          PageRequest pagination = 2;
 *  }
 */
export interface PageRequest {
	/**
	 * key is a value returned in PageResponse.next_key to begin
	 * querying the next page most efficiently. Only one of offset or key
	 * should be set.
	 */
	key: Uint8Array;
	/**
	 * offset is a numeric offset that can be used when key is unavailable.
	 * It is less efficient than using key. Only one of offset or key should
	 * be set.
	 */
	offset: Long;
	/**
	 * limit is the total number of results to be returned in the result page.
	 * If left empty it will default to a value to be set by each app.
	 */
	limit: Long;
	/**
	 * count_total is set to true  to indicate that the result set should include
	 * a count of the total number of items available for pagination in UIs.
	 * count_total is only respected when offset is used. It is ignored when key
	 * is set.
	 */
	countTotal: boolean;
	/** reverse is set to true if results are to be returned in the descending order. */
	reverse: boolean;
}
/**
 * PageResponse is to be embedded in gRPC response messages where the
 * corresponding request message has used PageRequest.
 *
 *  message SomeResponse {
 *          repeated Bar results = 1;
 *          PageResponse page = 2;
 *  }
 */
export interface PageResponse {
	/**
	 * next_key is the key to be passed to PageRequest.key to
	 * query the next page most efficiently
	 */
	nextKey: Uint8Array;
	/**
	 * total is total number of results available if PageRequest.count_total
	 * was set, its value is undefined otherwise
	 */
	total: Long;
}
declare const PageRequest: {
	encode(message: PageRequest, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): PageRequest;
	fromJSON(object: any): PageRequest;
	toJSON(message: PageRequest): unknown;
	fromPartial<I extends {
		key?: Uint8Array;
		offset?: string | number | Long.Long;
		limit?: string | number | Long.Long;
		countTotal?: boolean;
		reverse?: boolean;
	} & {
		key?: Uint8Array;
		offset?: string | number | (Long.Long & {
			high: number;
			low: number;
			unsigned: boolean;
			add: (addend: string | number | Long.Long) => Long.Long;
			and: (other: string | number | Long.Long) => Long.Long;
			compare: (other: string | number | Long.Long) => number;
			comp: (other: string | number | Long.Long) => number;
			divide: (divisor: string | number | Long.Long) => Long.Long;
			div: (divisor: string | number | Long.Long) => Long.Long;
			equals: (other: string | number | Long.Long) => boolean;
			eq: (other: string | number | Long.Long) => boolean;
			getHighBits: () => number;
			getHighBitsUnsigned: () => number;
			getLowBits: () => number;
			getLowBitsUnsigned: () => number;
			getNumBitsAbs: () => number;
			greaterThan: (other: string | number | Long.Long) => boolean;
			gt: (other: string | number | Long.Long) => boolean;
			greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
			gte: (other: string | number | Long.Long) => boolean;
			isEven: () => boolean;
			isNegative: () => boolean;
			isOdd: () => boolean;
			isPositive: () => boolean;
			isZero: () => boolean;
			lessThan: (other: string | number | Long.Long) => boolean;
			lt: (other: string | number | Long.Long) => boolean;
			lessThanOrEqual: (other: string | number | Long.Long) => boolean;
			lte: (other: string | number | Long.Long) => boolean;
			modulo: (other: string | number | Long.Long) => Long.Long;
			mod: (other: string | number | Long.Long) => Long.Long;
			multiply: (multiplier: string | number | Long.Long) => Long.Long;
			mul: (multiplier: string | number | Long.Long) => Long.Long;
			negate: () => Long.Long;
			neg: () => Long.Long;
			not: () => Long.Long;
			notEquals: (other: string | number | Long.Long) => boolean;
			neq: (other: string | number | Long.Long) => boolean;
			or: (other: string | number | Long.Long) => Long.Long;
			shiftLeft: (numBits: number | Long.Long) => Long.Long;
			shl: (numBits: number | Long.Long) => Long.Long;
			shiftRight: (numBits: number | Long.Long) => Long.Long;
			shr: (numBits: number | Long.Long) => Long.Long;
			shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
			shru: (numBits: number | Long.Long) => Long.Long;
			subtract: (subtrahend: string | number | Long.Long) => Long.Long;
			sub: (subtrahend: string | number | Long.Long) => Long.Long;
			toInt: () => number;
			toNumber: () => number;
			toBytes: (le?: boolean) => number[];
			toBytesLE: () => number[];
			toBytesBE: () => number[];
			toSigned: () => Long.Long;
			toString: (radix?: number) => string;
			toUnsigned: () => Long.Long;
			xor: (other: string | number | Long.Long) => Long.Long;
		} & Record<Exclude<keyof I["offset"], keyof Long.Long>, never>);
		limit?: string | number | (Long.Long & {
			high: number;
			low: number;
			unsigned: boolean;
			add: (addend: string | number | Long.Long) => Long.Long;
			and: (other: string | number | Long.Long) => Long.Long;
			compare: (other: string | number | Long.Long) => number;
			comp: (other: string | number | Long.Long) => number;
			divide: (divisor: string | number | Long.Long) => Long.Long;
			div: (divisor: string | number | Long.Long) => Long.Long;
			equals: (other: string | number | Long.Long) => boolean;
			eq: (other: string | number | Long.Long) => boolean;
			getHighBits: () => number;
			getHighBitsUnsigned: () => number;
			getLowBits: () => number;
			getLowBitsUnsigned: () => number;
			getNumBitsAbs: () => number;
			greaterThan: (other: string | number | Long.Long) => boolean;
			gt: (other: string | number | Long.Long) => boolean;
			greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
			gte: (other: string | number | Long.Long) => boolean;
			isEven: () => boolean;
			isNegative: () => boolean;
			isOdd: () => boolean;
			isPositive: () => boolean;
			isZero: () => boolean;
			lessThan: (other: string | number | Long.Long) => boolean;
			lt: (other: string | number | Long.Long) => boolean;
			lessThanOrEqual: (other: string | number | Long.Long) => boolean;
			lte: (other: string | number | Long.Long) => boolean;
			modulo: (other: string | number | Long.Long) => Long.Long;
			mod: (other: string | number | Long.Long) => Long.Long;
			multiply: (multiplier: string | number | Long.Long) => Long.Long;
			mul: (multiplier: string | number | Long.Long) => Long.Long;
			negate: () => Long.Long;
			neg: () => Long.Long;
			not: () => Long.Long;
			notEquals: (other: string | number | Long.Long) => boolean;
			neq: (other: string | number | Long.Long) => boolean;
			or: (other: string | number | Long.Long) => Long.Long;
			shiftLeft: (numBits: number | Long.Long) => Long.Long;
			shl: (numBits: number | Long.Long) => Long.Long;
			shiftRight: (numBits: number | Long.Long) => Long.Long;
			shr: (numBits: number | Long.Long) => Long.Long;
			shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
			shru: (numBits: number | Long.Long) => Long.Long;
			subtract: (subtrahend: string | number | Long.Long) => Long.Long;
			sub: (subtrahend: string | number | Long.Long) => Long.Long;
			toInt: () => number;
			toNumber: () => number;
			toBytes: (le?: boolean) => number[];
			toBytesLE: () => number[];
			toBytesBE: () => number[];
			toSigned: () => Long.Long;
			toString: (radix?: number) => string;
			toUnsigned: () => Long.Long;
			xor: (other: string | number | Long.Long) => Long.Long;
		} & Record<Exclude<keyof I["limit"], keyof Long.Long>, never>);
		countTotal?: boolean;
		reverse?: boolean;
	} & Record<Exclude<keyof I, keyof PageRequest>, never>>(object: I): PageRequest;
};
declare const PageResponse: {
	encode(message: PageResponse, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): PageResponse;
	fromJSON(object: any): PageResponse;
	toJSON(message: PageResponse): unknown;
	fromPartial<I extends {
		nextKey?: Uint8Array;
		total?: string | number | Long.Long;
	} & {
		nextKey?: Uint8Array;
		total?: string | number | (Long.Long & {
			high: number;
			low: number;
			unsigned: boolean;
			add: (addend: string | number | Long.Long) => Long.Long;
			and: (other: string | number | Long.Long) => Long.Long;
			compare: (other: string | number | Long.Long) => number;
			comp: (other: string | number | Long.Long) => number;
			divide: (divisor: string | number | Long.Long) => Long.Long;
			div: (divisor: string | number | Long.Long) => Long.Long;
			equals: (other: string | number | Long.Long) => boolean;
			eq: (other: string | number | Long.Long) => boolean;
			getHighBits: () => number;
			getHighBitsUnsigned: () => number;
			getLowBits: () => number;
			getLowBitsUnsigned: () => number;
			getNumBitsAbs: () => number;
			greaterThan: (other: string | number | Long.Long) => boolean;
			gt: (other: string | number | Long.Long) => boolean;
			greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
			gte: (other: string | number | Long.Long) => boolean;
			isEven: () => boolean;
			isNegative: () => boolean;
			isOdd: () => boolean;
			isPositive: () => boolean;
			isZero: () => boolean;
			lessThan: (other: string | number | Long.Long) => boolean;
			lt: (other: string | number | Long.Long) => boolean;
			lessThanOrEqual: (other: string | number | Long.Long) => boolean;
			lte: (other: string | number | Long.Long) => boolean;
			modulo: (other: string | number | Long.Long) => Long.Long;
			mod: (other: string | number | Long.Long) => Long.Long;
			multiply: (multiplier: string | number | Long.Long) => Long.Long;
			mul: (multiplier: string | number | Long.Long) => Long.Long;
			negate: () => Long.Long;
			neg: () => Long.Long;
			not: () => Long.Long;
			notEquals: (other: string | number | Long.Long) => boolean;
			neq: (other: string | number | Long.Long) => boolean;
			or: (other: string | number | Long.Long) => Long.Long;
			shiftLeft: (numBits: number | Long.Long) => Long.Long;
			shl: (numBits: number | Long.Long) => Long.Long;
			shiftRight: (numBits: number | Long.Long) => Long.Long;
			shr: (numBits: number | Long.Long) => Long.Long;
			shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
			shru: (numBits: number | Long.Long) => Long.Long;
			subtract: (subtrahend: string | number | Long.Long) => Long.Long;
			sub: (subtrahend: string | number | Long.Long) => Long.Long;
			toInt: () => number;
			toNumber: () => number;
			toBytes: (le?: boolean) => number[];
			toBytesLE: () => number[];
			toBytesBE: () => number[];
			toSigned: () => Long.Long;
			toString: (radix?: number) => string;
			toUnsigned: () => Long.Long;
			xor: (other: string | number | Long.Long) => Long.Long;
		} & Record<Exclude<keyof I["total"], keyof Long.Long>, never>);
	} & Record<Exclude<keyof I, keyof PageResponse>, never>>(object: I): PageResponse;
};
/** Params defines the parameters for the bank module. */
export interface Params {
	sendEnabled: SendEnabled[];
	defaultSendEnabled: boolean;
}
/**
 * SendEnabled maps coin denom to a send_enabled status (whether a denom is
 * sendable).
 */
export interface SendEnabled {
	denom: string;
	enabled: boolean;
}
/**
 * DenomUnit represents a struct that describes a given
 * denomination unit of the basic token.
 */
export interface DenomUnit {
	/** denom represents the string name of the given denom unit (e.g uatom). */
	denom: string;
	/**
	 * exponent represents power of 10 exponent that one must
	 * raise the base_denom to in order to equal the given DenomUnit's denom
	 * 1 denom = 1^exponent base_denom
	 * (e.g. with a base_denom of uatom, one can create a DenomUnit of 'atom' with
	 * exponent = 6, thus: 1 atom = 10^6 uatom).
	 */
	exponent: number;
	/** aliases is a list of string aliases for the given denom */
	aliases: string[];
}
/**
 * Metadata represents a struct that describes
 * a basic token.
 */
export interface Metadata {
	description: string;
	/** denom_units represents the list of DenomUnit's for a given coin */
	denomUnits: DenomUnit[];
	/** base represents the base denom (should be the DenomUnit with exponent = 0). */
	base: string;
	/**
	 * display indicates the suggested denom that should be
	 * displayed in clients.
	 */
	display: string;
	/** name defines the name of the token (eg: Cosmos Atom) */
	name: string;
	/**
	 * symbol is the token symbol usually shown on exchanges (eg: ATOM). This can
	 * be the same as the display.
	 */
	symbol: string;
}
declare const Params: {
	encode(message: Params, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): Params;
	fromJSON(object: any): Params;
	toJSON(message: Params): unknown;
	fromPartial<I extends {
		sendEnabled?: {
			denom?: string;
			enabled?: boolean;
		}[];
		defaultSendEnabled?: boolean;
	} & {
		sendEnabled?: {
			denom?: string;
			enabled?: boolean;
		}[] & ({
			denom?: string;
			enabled?: boolean;
		} & {
			denom?: string;
			enabled?: boolean;
		} & Record<Exclude<keyof I["sendEnabled"][number], keyof SendEnabled>, never>)[] & Record<Exclude<keyof I["sendEnabled"], keyof {
			denom?: string;
			enabled?: boolean;
		}[]>, never>;
		defaultSendEnabled?: boolean;
	} & Record<Exclude<keyof I, keyof Params>, never>>(object: I): Params;
};
declare const SendEnabled: {
	encode(message: SendEnabled, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): SendEnabled;
	fromJSON(object: any): SendEnabled;
	toJSON(message: SendEnabled): unknown;
	fromPartial<I extends {
		denom?: string;
		enabled?: boolean;
	} & {
		denom?: string;
		enabled?: boolean;
	} & Record<Exclude<keyof I, keyof SendEnabled>, never>>(object: I): SendEnabled;
};
declare const DenomUnit: {
	encode(message: DenomUnit, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): DenomUnit;
	fromJSON(object: any): DenomUnit;
	toJSON(message: DenomUnit): unknown;
	fromPartial<I extends {
		denom?: string;
		exponent?: number;
		aliases?: string[];
	} & {
		denom?: string;
		exponent?: number;
		aliases?: string[] & string[] & Record<Exclude<keyof I["aliases"], keyof string[]>, never>;
	} & Record<Exclude<keyof I, keyof DenomUnit>, never>>(object: I): DenomUnit;
};
declare const Metadata: {
	encode(message: Metadata, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): Metadata;
	fromJSON(object: any): Metadata;
	toJSON(message: Metadata): unknown;
	fromPartial<I extends {
		description?: string;
		denomUnits?: {
			denom?: string;
			exponent?: number;
			aliases?: string[];
		}[];
		base?: string;
		display?: string;
		name?: string;
		symbol?: string;
	} & {
		description?: string;
		denomUnits?: {
			denom?: string;
			exponent?: number;
			aliases?: string[];
		}[] & ({
			denom?: string;
			exponent?: number;
			aliases?: string[];
		} & {
			denom?: string;
			exponent?: number;
			aliases?: string[] & string[] & Record<Exclude<keyof I["denomUnits"][number]["aliases"], keyof string[]>, never>;
		} & Record<Exclude<keyof I["denomUnits"][number], keyof DenomUnit>, never>)[] & Record<Exclude<keyof I["denomUnits"], keyof {
			denom?: string;
			exponent?: number;
			aliases?: string[];
		}[]>, never>;
		base?: string;
		display?: string;
		name?: string;
		symbol?: string;
	} & Record<Exclude<keyof I, keyof Metadata>, never>>(object: I): Metadata;
};
/** QueryBalanceRequest is the request type for the Query/Balance RPC method. */
export interface QueryBalanceRequest {
	/** address is the address to query balances for. */
	address: string;
	/** denom is the coin denom to query balances for. */
	denom: string;
}
/** QueryBalanceResponse is the response type for the Query/Balance RPC method. */
export interface QueryBalanceResponse {
	/** balance is the balance of the coin. */
	balance?: Coin;
}
/** QueryBalanceRequest is the request type for the Query/AllBalances RPC method. */
export interface QueryAllBalancesRequest {
	/** address is the address to query balances for. */
	address: string;
	/** pagination defines an optional pagination for the request. */
	pagination?: PageRequest;
}
/**
 * QueryAllBalancesResponse is the response type for the Query/AllBalances RPC
 * method.
 */
export interface QueryAllBalancesResponse {
	/** balances is the balances of all the coins. */
	balances: Coin[];
	/** pagination defines the pagination in the response. */
	pagination?: PageResponse;
}
/**
 * QueryTotalSupplyRequest is the request type for the Query/TotalSupply RPC
 * method.
 */
export interface QueryTotalSupplyRequest {
	/** pagination defines an optional pagination for the request. */
	pagination?: PageRequest;
}
/**
 * QueryTotalSupplyResponse is the response type for the Query/TotalSupply RPC
 * method
 */
export interface QueryTotalSupplyResponse {
	/** supply is the supply of the coins */
	supply: Coin[];
	/** pagination defines the pagination in the response. */
	pagination?: PageResponse;
}
/** QuerySupplyOfRequest is the request type for the Query/SupplyOf RPC method. */
export interface QuerySupplyOfRequest {
	/** denom is the coin denom to query balances for. */
	denom: string;
}
/** QuerySupplyOfResponse is the response type for the Query/SupplyOf RPC method. */
export interface QuerySupplyOfResponse {
	/** amount is the supply of the coin. */
	amount?: Coin;
}
/** QueryParamsRequest defines the request type for querying x/bank parameters. */
export interface QueryParamsRequest {
}
/** QueryParamsResponse defines the response type for querying x/bank parameters. */
export interface QueryParamsResponse {
	params?: Params;
}
/** QueryDenomsMetadataRequest is the request type for the Query/DenomsMetadata RPC method. */
export interface QueryDenomsMetadataRequest {
	/** pagination defines an optional pagination for the request. */
	pagination?: PageRequest;
}
/**
 * QueryDenomsMetadataResponse is the response type for the Query/DenomsMetadata RPC
 * method.
 */
export interface QueryDenomsMetadataResponse {
	/** metadata provides the client information for all the registered tokens. */
	metadatas: Metadata[];
	/** pagination defines the pagination in the response. */
	pagination?: PageResponse;
}
/** QueryDenomMetadataRequest is the request type for the Query/DenomMetadata RPC method. */
export interface QueryDenomMetadataRequest {
	/** denom is the coin denom to query the metadata for. */
	denom: string;
}
/**
 * QueryDenomMetadataResponse is the response type for the Query/DenomMetadata RPC
 * method.
 */
export interface QueryDenomMetadataResponse {
	/** metadata describes and provides all the client information for the requested token. */
	metadata?: Metadata;
}
declare const QueryBalanceRequest: {
	encode(message: QueryBalanceRequest, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryBalanceRequest;
	fromJSON(object: any): QueryBalanceRequest;
	toJSON(message: QueryBalanceRequest): unknown;
	fromPartial<I extends {
		address?: string;
		denom?: string;
	} & {
		address?: string;
		denom?: string;
	} & Record<Exclude<keyof I, keyof QueryBalanceRequest>, never>>(object: I): QueryBalanceRequest;
};
declare const QueryBalanceResponse: {
	encode(message: QueryBalanceResponse, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryBalanceResponse;
	fromJSON(object: any): QueryBalanceResponse;
	toJSON(message: QueryBalanceResponse): unknown;
	fromPartial<I extends {
		balance?: {
			denom?: string;
			amount?: string;
		};
	} & {
		balance?: {
			denom?: string;
			amount?: string;
		} & {
			denom?: string;
			amount?: string;
		} & Record<Exclude<keyof I["balance"], keyof Coin>, never>;
	} & Record<Exclude<keyof I, "balance">, never>>(object: I): QueryBalanceResponse;
};
declare const QueryAllBalancesRequest: {
	encode(message: QueryAllBalancesRequest, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryAllBalancesRequest;
	fromJSON(object: any): QueryAllBalancesRequest;
	toJSON(message: QueryAllBalancesRequest): unknown;
	fromPartial<I extends {
		address?: string;
		pagination?: {
			key?: Uint8Array;
			offset?: string | number | Long.Long;
			limit?: string | number | Long.Long;
			countTotal?: boolean;
			reverse?: boolean;
		};
	} & {
		address?: string;
		pagination?: {
			key?: Uint8Array;
			offset?: string | number | Long.Long;
			limit?: string | number | Long.Long;
			countTotal?: boolean;
			reverse?: boolean;
		} & {
			key?: Uint8Array;
			offset?: string | number | (Long.Long & {
				high: number;
				low: number;
				unsigned: boolean;
				add: (addend: string | number | Long.Long) => Long.Long;
				and: (other: string | number | Long.Long) => Long.Long;
				compare: (other: string | number | Long.Long) => number;
				comp: (other: string | number | Long.Long) => number;
				divide: (divisor: string | number | Long.Long) => Long.Long;
				div: (divisor: string | number | Long.Long) => Long.Long;
				equals: (other: string | number | Long.Long) => boolean;
				eq: (other: string | number | Long.Long) => boolean;
				getHighBits: () => number;
				getHighBitsUnsigned: () => number;
				getLowBits: () => number;
				getLowBitsUnsigned: () => number;
				getNumBitsAbs: () => number;
				greaterThan: (other: string | number | Long.Long) => boolean;
				gt: (other: string | number | Long.Long) => boolean;
				greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
				gte: (other: string | number | Long.Long) => boolean;
				isEven: () => boolean;
				isNegative: () => boolean;
				isOdd: () => boolean;
				isPositive: () => boolean;
				isZero: () => boolean;
				lessThan: (other: string | number | Long.Long) => boolean;
				lt: (other: string | number | Long.Long) => boolean;
				lessThanOrEqual: (other: string | number | Long.Long) => boolean;
				lte: (other: string | number | Long.Long) => boolean;
				modulo: (other: string | number | Long.Long) => Long.Long;
				mod: (other: string | number | Long.Long) => Long.Long;
				multiply: (multiplier: string | number | Long.Long) => Long.Long;
				mul: (multiplier: string | number | Long.Long) => Long.Long;
				negate: () => Long.Long;
				neg: () => Long.Long;
				not: () => Long.Long;
				notEquals: (other: string | number | Long.Long) => boolean;
				neq: (other: string | number | Long.Long) => boolean;
				or: (other: string | number | Long.Long) => Long.Long;
				shiftLeft: (numBits: number | Long.Long) => Long.Long;
				shl: (numBits: number | Long.Long) => Long.Long;
				shiftRight: (numBits: number | Long.Long) => Long.Long;
				shr: (numBits: number | Long.Long) => Long.Long;
				shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
				shru: (numBits: number | Long.Long) => Long.Long;
				subtract: (subtrahend: string | number | Long.Long) => Long.Long;
				sub: (subtrahend: string | number | Long.Long) => Long.Long;
				toInt: () => number;
				toNumber: () => number;
				toBytes: (le?: boolean) => number[];
				toBytesLE: () => number[];
				toBytesBE: () => number[];
				toSigned: () => Long.Long;
				toString: (radix?: number) => string;
				toUnsigned: () => Long.Long;
				xor: (other: string | number | Long.Long) => Long.Long;
			} & Record<Exclude<keyof I["pagination"]["offset"], keyof Long.Long>, never>);
			limit?: string | number | (Long.Long & {
				high: number;
				low: number;
				unsigned: boolean;
				add: (addend: string | number | Long.Long) => Long.Long;
				and: (other: string | number | Long.Long) => Long.Long;
				compare: (other: string | number | Long.Long) => number;
				comp: (other: string | number | Long.Long) => number;
				divide: (divisor: string | number | Long.Long) => Long.Long;
				div: (divisor: string | number | Long.Long) => Long.Long;
				equals: (other: string | number | Long.Long) => boolean;
				eq: (other: string | number | Long.Long) => boolean;
				getHighBits: () => number;
				getHighBitsUnsigned: () => number;
				getLowBits: () => number;
				getLowBitsUnsigned: () => number;
				getNumBitsAbs: () => number;
				greaterThan: (other: string | number | Long.Long) => boolean;
				gt: (other: string | number | Long.Long) => boolean;
				greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
				gte: (other: string | number | Long.Long) => boolean;
				isEven: () => boolean;
				isNegative: () => boolean;
				isOdd: () => boolean;
				isPositive: () => boolean;
				isZero: () => boolean;
				lessThan: (other: string | number | Long.Long) => boolean;
				lt: (other: string | number | Long.Long) => boolean;
				lessThanOrEqual: (other: string | number | Long.Long) => boolean;
				lte: (other: string | number | Long.Long) => boolean;
				modulo: (other: string | number | Long.Long) => Long.Long;
				mod: (other: string | number | Long.Long) => Long.Long;
				multiply: (multiplier: string | number | Long.Long) => Long.Long;
				mul: (multiplier: string | number | Long.Long) => Long.Long;
				negate: () => Long.Long;
				neg: () => Long.Long;
				not: () => Long.Long;
				notEquals: (other: string | number | Long.Long) => boolean;
				neq: (other: string | number | Long.Long) => boolean;
				or: (other: string | number | Long.Long) => Long.Long;
				shiftLeft: (numBits: number | Long.Long) => Long.Long;
				shl: (numBits: number | Long.Long) => Long.Long;
				shiftRight: (numBits: number | Long.Long) => Long.Long;
				shr: (numBits: number | Long.Long) => Long.Long;
				shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
				shru: (numBits: number | Long.Long) => Long.Long;
				subtract: (subtrahend: string | number | Long.Long) => Long.Long;
				sub: (subtrahend: string | number | Long.Long) => Long.Long;
				toInt: () => number;
				toNumber: () => number;
				toBytes: (le?: boolean) => number[];
				toBytesLE: () => number[];
				toBytesBE: () => number[];
				toSigned: () => Long.Long;
				toString: (radix?: number) => string;
				toUnsigned: () => Long.Long;
				xor: (other: string | number | Long.Long) => Long.Long;
			} & Record<Exclude<keyof I["pagination"]["limit"], keyof Long.Long>, never>);
			countTotal?: boolean;
			reverse?: boolean;
		} & Record<Exclude<keyof I["pagination"], keyof PageRequest>, never>;
	} & Record<Exclude<keyof I, keyof QueryAllBalancesRequest>, never>>(object: I): QueryAllBalancesRequest;
};
declare const QueryAllBalancesResponse: {
	encode(message: QueryAllBalancesResponse, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryAllBalancesResponse;
	fromJSON(object: any): QueryAllBalancesResponse;
	toJSON(message: QueryAllBalancesResponse): unknown;
	fromPartial<I extends {
		balances?: {
			denom?: string;
			amount?: string;
		}[];
		pagination?: {
			nextKey?: Uint8Array;
			total?: string | number | Long.Long;
		};
	} & {
		balances?: {
			denom?: string;
			amount?: string;
		}[] & ({
			denom?: string;
			amount?: string;
		} & {
			denom?: string;
			amount?: string;
		} & Record<Exclude<keyof I["balances"][number], keyof Coin>, never>)[] & Record<Exclude<keyof I["balances"], keyof {
			denom?: string;
			amount?: string;
		}[]>, never>;
		pagination?: {
			nextKey?: Uint8Array;
			total?: string | number | Long.Long;
		} & {
			nextKey?: Uint8Array;
			total?: string | number | (Long.Long & {
				high: number;
				low: number;
				unsigned: boolean;
				add: (addend: string | number | Long.Long) => Long.Long;
				and: (other: string | number | Long.Long) => Long.Long;
				compare: (other: string | number | Long.Long) => number;
				comp: (other: string | number | Long.Long) => number;
				divide: (divisor: string | number | Long.Long) => Long.Long;
				div: (divisor: string | number | Long.Long) => Long.Long;
				equals: (other: string | number | Long.Long) => boolean;
				eq: (other: string | number | Long.Long) => boolean;
				getHighBits: () => number;
				getHighBitsUnsigned: () => number;
				getLowBits: () => number;
				getLowBitsUnsigned: () => number;
				getNumBitsAbs: () => number;
				greaterThan: (other: string | number | Long.Long) => boolean;
				gt: (other: string | number | Long.Long) => boolean;
				greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
				gte: (other: string | number | Long.Long) => boolean;
				isEven: () => boolean;
				isNegative: () => boolean;
				isOdd: () => boolean;
				isPositive: () => boolean;
				isZero: () => boolean;
				lessThan: (other: string | number | Long.Long) => boolean;
				lt: (other: string | number | Long.Long) => boolean;
				lessThanOrEqual: (other: string | number | Long.Long) => boolean;
				lte: (other: string | number | Long.Long) => boolean;
				modulo: (other: string | number | Long.Long) => Long.Long;
				mod: (other: string | number | Long.Long) => Long.Long;
				multiply: (multiplier: string | number | Long.Long) => Long.Long;
				mul: (multiplier: string | number | Long.Long) => Long.Long;
				negate: () => Long.Long;
				neg: () => Long.Long;
				not: () => Long.Long;
				notEquals: (other: string | number | Long.Long) => boolean;
				neq: (other: string | number | Long.Long) => boolean;
				or: (other: string | number | Long.Long) => Long.Long;
				shiftLeft: (numBits: number | Long.Long) => Long.Long;
				shl: (numBits: number | Long.Long) => Long.Long;
				shiftRight: (numBits: number | Long.Long) => Long.Long;
				shr: (numBits: number | Long.Long) => Long.Long;
				shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
				shru: (numBits: number | Long.Long) => Long.Long;
				subtract: (subtrahend: string | number | Long.Long) => Long.Long;
				sub: (subtrahend: string | number | Long.Long) => Long.Long;
				toInt: () => number;
				toNumber: () => number;
				toBytes: (le?: boolean) => number[];
				toBytesLE: () => number[];
				toBytesBE: () => number[];
				toSigned: () => Long.Long;
				toString: (radix?: number) => string;
				toUnsigned: () => Long.Long;
				xor: (other: string | number | Long.Long) => Long.Long;
			} & Record<Exclude<keyof I["pagination"]["total"], keyof Long.Long>, never>);
		} & Record<Exclude<keyof I["pagination"], keyof PageResponse>, never>;
	} & Record<Exclude<keyof I, keyof QueryAllBalancesResponse>, never>>(object: I): QueryAllBalancesResponse;
};
declare const QueryTotalSupplyRequest: {
	encode(message: QueryTotalSupplyRequest, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryTotalSupplyRequest;
	fromJSON(object: any): QueryTotalSupplyRequest;
	toJSON(message: QueryTotalSupplyRequest): unknown;
	fromPartial<I extends {
		pagination?: {
			key?: Uint8Array;
			offset?: string | number | Long.Long;
			limit?: string | number | Long.Long;
			countTotal?: boolean;
			reverse?: boolean;
		};
	} & {
		pagination?: {
			key?: Uint8Array;
			offset?: string | number | Long.Long;
			limit?: string | number | Long.Long;
			countTotal?: boolean;
			reverse?: boolean;
		} & {
			key?: Uint8Array;
			offset?: string | number | (Long.Long & {
				high: number;
				low: number;
				unsigned: boolean;
				add: (addend: string | number | Long.Long) => Long.Long;
				and: (other: string | number | Long.Long) => Long.Long;
				compare: (other: string | number | Long.Long) => number;
				comp: (other: string | number | Long.Long) => number;
				divide: (divisor: string | number | Long.Long) => Long.Long;
				div: (divisor: string | number | Long.Long) => Long.Long;
				equals: (other: string | number | Long.Long) => boolean;
				eq: (other: string | number | Long.Long) => boolean;
				getHighBits: () => number;
				getHighBitsUnsigned: () => number;
				getLowBits: () => number;
				getLowBitsUnsigned: () => number;
				getNumBitsAbs: () => number;
				greaterThan: (other: string | number | Long.Long) => boolean;
				gt: (other: string | number | Long.Long) => boolean;
				greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
				gte: (other: string | number | Long.Long) => boolean;
				isEven: () => boolean;
				isNegative: () => boolean;
				isOdd: () => boolean;
				isPositive: () => boolean;
				isZero: () => boolean;
				lessThan: (other: string | number | Long.Long) => boolean;
				lt: (other: string | number | Long.Long) => boolean;
				lessThanOrEqual: (other: string | number | Long.Long) => boolean;
				lte: (other: string | number | Long.Long) => boolean;
				modulo: (other: string | number | Long.Long) => Long.Long;
				mod: (other: string | number | Long.Long) => Long.Long;
				multiply: (multiplier: string | number | Long.Long) => Long.Long;
				mul: (multiplier: string | number | Long.Long) => Long.Long;
				negate: () => Long.Long;
				neg: () => Long.Long;
				not: () => Long.Long;
				notEquals: (other: string | number | Long.Long) => boolean;
				neq: (other: string | number | Long.Long) => boolean;
				or: (other: string | number | Long.Long) => Long.Long;
				shiftLeft: (numBits: number | Long.Long) => Long.Long;
				shl: (numBits: number | Long.Long) => Long.Long;
				shiftRight: (numBits: number | Long.Long) => Long.Long;
				shr: (numBits: number | Long.Long) => Long.Long;
				shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
				shru: (numBits: number | Long.Long) => Long.Long;
				subtract: (subtrahend: string | number | Long.Long) => Long.Long;
				sub: (subtrahend: string | number | Long.Long) => Long.Long;
				toInt: () => number;
				toNumber: () => number;
				toBytes: (le?: boolean) => number[];
				toBytesLE: () => number[];
				toBytesBE: () => number[];
				toSigned: () => Long.Long;
				toString: (radix?: number) => string;
				toUnsigned: () => Long.Long;
				xor: (other: string | number | Long.Long) => Long.Long;
			} & Record<Exclude<keyof I["pagination"]["offset"], keyof Long.Long>, never>);
			limit?: string | number | (Long.Long & {
				high: number;
				low: number;
				unsigned: boolean;
				add: (addend: string | number | Long.Long) => Long.Long;
				and: (other: string | number | Long.Long) => Long.Long;
				compare: (other: string | number | Long.Long) => number;
				comp: (other: string | number | Long.Long) => number;
				divide: (divisor: string | number | Long.Long) => Long.Long;
				div: (divisor: string | number | Long.Long) => Long.Long;
				equals: (other: string | number | Long.Long) => boolean;
				eq: (other: string | number | Long.Long) => boolean;
				getHighBits: () => number;
				getHighBitsUnsigned: () => number;
				getLowBits: () => number;
				getLowBitsUnsigned: () => number;
				getNumBitsAbs: () => number;
				greaterThan: (other: string | number | Long.Long) => boolean;
				gt: (other: string | number | Long.Long) => boolean;
				greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
				gte: (other: string | number | Long.Long) => boolean;
				isEven: () => boolean;
				isNegative: () => boolean;
				isOdd: () => boolean;
				isPositive: () => boolean;
				isZero: () => boolean;
				lessThan: (other: string | number | Long.Long) => boolean;
				lt: (other: string | number | Long.Long) => boolean;
				lessThanOrEqual: (other: string | number | Long.Long) => boolean;
				lte: (other: string | number | Long.Long) => boolean;
				modulo: (other: string | number | Long.Long) => Long.Long;
				mod: (other: string | number | Long.Long) => Long.Long;
				multiply: (multiplier: string | number | Long.Long) => Long.Long;
				mul: (multiplier: string | number | Long.Long) => Long.Long;
				negate: () => Long.Long;
				neg: () => Long.Long;
				not: () => Long.Long;
				notEquals: (other: string | number | Long.Long) => boolean;
				neq: (other: string | number | Long.Long) => boolean;
				or: (other: string | number | Long.Long) => Long.Long;
				shiftLeft: (numBits: number | Long.Long) => Long.Long;
				shl: (numBits: number | Long.Long) => Long.Long;
				shiftRight: (numBits: number | Long.Long) => Long.Long;
				shr: (numBits: number | Long.Long) => Long.Long;
				shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
				shru: (numBits: number | Long.Long) => Long.Long;
				subtract: (subtrahend: string | number | Long.Long) => Long.Long;
				sub: (subtrahend: string | number | Long.Long) => Long.Long;
				toInt: () => number;
				toNumber: () => number;
				toBytes: (le?: boolean) => number[];
				toBytesLE: () => number[];
				toBytesBE: () => number[];
				toSigned: () => Long.Long;
				toString: (radix?: number) => string;
				toUnsigned: () => Long.Long;
				xor: (other: string | number | Long.Long) => Long.Long;
			} & Record<Exclude<keyof I["pagination"]["limit"], keyof Long.Long>, never>);
			countTotal?: boolean;
			reverse?: boolean;
		} & Record<Exclude<keyof I["pagination"], keyof PageRequest>, never>;
	} & Record<Exclude<keyof I, "pagination">, never>>(object: I): QueryTotalSupplyRequest;
};
declare const QueryTotalSupplyResponse: {
	encode(message: QueryTotalSupplyResponse, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryTotalSupplyResponse;
	fromJSON(object: any): QueryTotalSupplyResponse;
	toJSON(message: QueryTotalSupplyResponse): unknown;
	fromPartial<I extends {
		supply?: {
			denom?: string;
			amount?: string;
		}[];
		pagination?: {
			nextKey?: Uint8Array;
			total?: string | number | Long.Long;
		};
	} & {
		supply?: {
			denom?: string;
			amount?: string;
		}[] & ({
			denom?: string;
			amount?: string;
		} & {
			denom?: string;
			amount?: string;
		} & Record<Exclude<keyof I["supply"][number], keyof Coin>, never>)[] & Record<Exclude<keyof I["supply"], keyof {
			denom?: string;
			amount?: string;
		}[]>, never>;
		pagination?: {
			nextKey?: Uint8Array;
			total?: string | number | Long.Long;
		} & {
			nextKey?: Uint8Array;
			total?: string | number | (Long.Long & {
				high: number;
				low: number;
				unsigned: boolean;
				add: (addend: string | number | Long.Long) => Long.Long;
				and: (other: string | number | Long.Long) => Long.Long;
				compare: (other: string | number | Long.Long) => number;
				comp: (other: string | number | Long.Long) => number;
				divide: (divisor: string | number | Long.Long) => Long.Long;
				div: (divisor: string | number | Long.Long) => Long.Long;
				equals: (other: string | number | Long.Long) => boolean;
				eq: (other: string | number | Long.Long) => boolean;
				getHighBits: () => number;
				getHighBitsUnsigned: () => number;
				getLowBits: () => number;
				getLowBitsUnsigned: () => number;
				getNumBitsAbs: () => number;
				greaterThan: (other: string | number | Long.Long) => boolean;
				gt: (other: string | number | Long.Long) => boolean;
				greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
				gte: (other: string | number | Long.Long) => boolean;
				isEven: () => boolean;
				isNegative: () => boolean;
				isOdd: () => boolean;
				isPositive: () => boolean;
				isZero: () => boolean;
				lessThan: (other: string | number | Long.Long) => boolean;
				lt: (other: string | number | Long.Long) => boolean;
				lessThanOrEqual: (other: string | number | Long.Long) => boolean;
				lte: (other: string | number | Long.Long) => boolean;
				modulo: (other: string | number | Long.Long) => Long.Long;
				mod: (other: string | number | Long.Long) => Long.Long;
				multiply: (multiplier: string | number | Long.Long) => Long.Long;
				mul: (multiplier: string | number | Long.Long) => Long.Long;
				negate: () => Long.Long;
				neg: () => Long.Long;
				not: () => Long.Long;
				notEquals: (other: string | number | Long.Long) => boolean;
				neq: (other: string | number | Long.Long) => boolean;
				or: (other: string | number | Long.Long) => Long.Long;
				shiftLeft: (numBits: number | Long.Long) => Long.Long;
				shl: (numBits: number | Long.Long) => Long.Long;
				shiftRight: (numBits: number | Long.Long) => Long.Long;
				shr: (numBits: number | Long.Long) => Long.Long;
				shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
				shru: (numBits: number | Long.Long) => Long.Long;
				subtract: (subtrahend: string | number | Long.Long) => Long.Long;
				sub: (subtrahend: string | number | Long.Long) => Long.Long;
				toInt: () => number;
				toNumber: () => number;
				toBytes: (le?: boolean) => number[];
				toBytesLE: () => number[];
				toBytesBE: () => number[];
				toSigned: () => Long.Long;
				toString: (radix?: number) => string;
				toUnsigned: () => Long.Long;
				xor: (other: string | number | Long.Long) => Long.Long;
			} & Record<Exclude<keyof I["pagination"]["total"], keyof Long.Long>, never>);
		} & Record<Exclude<keyof I["pagination"], keyof PageResponse>, never>;
	} & Record<Exclude<keyof I, keyof QueryTotalSupplyResponse>, never>>(object: I): QueryTotalSupplyResponse;
};
declare const QuerySupplyOfRequest: {
	encode(message: QuerySupplyOfRequest, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QuerySupplyOfRequest;
	fromJSON(object: any): QuerySupplyOfRequest;
	toJSON(message: QuerySupplyOfRequest): unknown;
	fromPartial<I extends {
		denom?: string;
	} & {
		denom?: string;
	} & Record<Exclude<keyof I, "denom">, never>>(object: I): QuerySupplyOfRequest;
};
declare const QuerySupplyOfResponse: {
	encode(message: QuerySupplyOfResponse, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QuerySupplyOfResponse;
	fromJSON(object: any): QuerySupplyOfResponse;
	toJSON(message: QuerySupplyOfResponse): unknown;
	fromPartial<I extends {
		amount?: {
			denom?: string;
			amount?: string;
		};
	} & {
		amount?: {
			denom?: string;
			amount?: string;
		} & {
			denom?: string;
			amount?: string;
		} & Record<Exclude<keyof I["amount"], keyof Coin>, never>;
	} & Record<Exclude<keyof I, "amount">, never>>(object: I): QuerySupplyOfResponse;
};
declare const QueryParamsRequest: {
	encode(_: QueryParamsRequest, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryParamsRequest;
	fromJSON(_: any): QueryParamsRequest;
	toJSON(_: QueryParamsRequest): unknown;
	fromPartial<I extends {} & {} & Record<Exclude<keyof I, never>, never>>(_: I): QueryParamsRequest;
};
declare const QueryParamsResponse: {
	encode(message: QueryParamsResponse, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryParamsResponse;
	fromJSON(object: any): QueryParamsResponse;
	toJSON(message: QueryParamsResponse): unknown;
	fromPartial<I extends {
		params?: {
			sendEnabled?: {
				denom?: string;
				enabled?: boolean;
			}[];
			defaultSendEnabled?: boolean;
		};
	} & {
		params?: {
			sendEnabled?: {
				denom?: string;
				enabled?: boolean;
			}[];
			defaultSendEnabled?: boolean;
		} & {
			sendEnabled?: {
				denom?: string;
				enabled?: boolean;
			}[] & ({
				denom?: string;
				enabled?: boolean;
			} & {
				denom?: string;
				enabled?: boolean;
			} & Record<Exclude<keyof I["params"]["sendEnabled"][number], keyof SendEnabled>, never>)[] & Record<Exclude<keyof I["params"]["sendEnabled"], keyof {
				denom?: string;
				enabled?: boolean;
			}[]>, never>;
			defaultSendEnabled?: boolean;
		} & Record<Exclude<keyof I["params"], keyof Params>, never>;
	} & Record<Exclude<keyof I, "params">, never>>(object: I): QueryParamsResponse;
};
declare const QueryDenomsMetadataRequest: {
	encode(message: QueryDenomsMetadataRequest, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryDenomsMetadataRequest;
	fromJSON(object: any): QueryDenomsMetadataRequest;
	toJSON(message: QueryDenomsMetadataRequest): unknown;
	fromPartial<I extends {
		pagination?: {
			key?: Uint8Array;
			offset?: string | number | Long.Long;
			limit?: string | number | Long.Long;
			countTotal?: boolean;
			reverse?: boolean;
		};
	} & {
		pagination?: {
			key?: Uint8Array;
			offset?: string | number | Long.Long;
			limit?: string | number | Long.Long;
			countTotal?: boolean;
			reverse?: boolean;
		} & {
			key?: Uint8Array;
			offset?: string | number | (Long.Long & {
				high: number;
				low: number;
				unsigned: boolean;
				add: (addend: string | number | Long.Long) => Long.Long;
				and: (other: string | number | Long.Long) => Long.Long;
				compare: (other: string | number | Long.Long) => number;
				comp: (other: string | number | Long.Long) => number;
				divide: (divisor: string | number | Long.Long) => Long.Long;
				div: (divisor: string | number | Long.Long) => Long.Long;
				equals: (other: string | number | Long.Long) => boolean;
				eq: (other: string | number | Long.Long) => boolean;
				getHighBits: () => number;
				getHighBitsUnsigned: () => number;
				getLowBits: () => number;
				getLowBitsUnsigned: () => number;
				getNumBitsAbs: () => number;
				greaterThan: (other: string | number | Long.Long) => boolean;
				gt: (other: string | number | Long.Long) => boolean;
				greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
				gte: (other: string | number | Long.Long) => boolean;
				isEven: () => boolean;
				isNegative: () => boolean;
				isOdd: () => boolean;
				isPositive: () => boolean;
				isZero: () => boolean;
				lessThan: (other: string | number | Long.Long) => boolean;
				lt: (other: string | number | Long.Long) => boolean;
				lessThanOrEqual: (other: string | number | Long.Long) => boolean;
				lte: (other: string | number | Long.Long) => boolean;
				modulo: (other: string | number | Long.Long) => Long.Long;
				mod: (other: string | number | Long.Long) => Long.Long;
				multiply: (multiplier: string | number | Long.Long) => Long.Long;
				mul: (multiplier: string | number | Long.Long) => Long.Long;
				negate: () => Long.Long;
				neg: () => Long.Long;
				not: () => Long.Long;
				notEquals: (other: string | number | Long.Long) => boolean;
				neq: (other: string | number | Long.Long) => boolean;
				or: (other: string | number | Long.Long) => Long.Long;
				shiftLeft: (numBits: number | Long.Long) => Long.Long;
				shl: (numBits: number | Long.Long) => Long.Long;
				shiftRight: (numBits: number | Long.Long) => Long.Long;
				shr: (numBits: number | Long.Long) => Long.Long;
				shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
				shru: (numBits: number | Long.Long) => Long.Long;
				subtract: (subtrahend: string | number | Long.Long) => Long.Long;
				sub: (subtrahend: string | number | Long.Long) => Long.Long;
				toInt: () => number;
				toNumber: () => number;
				toBytes: (le?: boolean) => number[];
				toBytesLE: () => number[];
				toBytesBE: () => number[];
				toSigned: () => Long.Long;
				toString: (radix?: number) => string;
				toUnsigned: () => Long.Long;
				xor: (other: string | number | Long.Long) => Long.Long;
			} & Record<Exclude<keyof I["pagination"]["offset"], keyof Long.Long>, never>);
			limit?: string | number | (Long.Long & {
				high: number;
				low: number;
				unsigned: boolean;
				add: (addend: string | number | Long.Long) => Long.Long;
				and: (other: string | number | Long.Long) => Long.Long;
				compare: (other: string | number | Long.Long) => number;
				comp: (other: string | number | Long.Long) => number;
				divide: (divisor: string | number | Long.Long) => Long.Long;
				div: (divisor: string | number | Long.Long) => Long.Long;
				equals: (other: string | number | Long.Long) => boolean;
				eq: (other: string | number | Long.Long) => boolean;
				getHighBits: () => number;
				getHighBitsUnsigned: () => number;
				getLowBits: () => number;
				getLowBitsUnsigned: () => number;
				getNumBitsAbs: () => number;
				greaterThan: (other: string | number | Long.Long) => boolean;
				gt: (other: string | number | Long.Long) => boolean;
				greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
				gte: (other: string | number | Long.Long) => boolean;
				isEven: () => boolean;
				isNegative: () => boolean;
				isOdd: () => boolean;
				isPositive: () => boolean;
				isZero: () => boolean;
				lessThan: (other: string | number | Long.Long) => boolean;
				lt: (other: string | number | Long.Long) => boolean;
				lessThanOrEqual: (other: string | number | Long.Long) => boolean;
				lte: (other: string | number | Long.Long) => boolean;
				modulo: (other: string | number | Long.Long) => Long.Long;
				mod: (other: string | number | Long.Long) => Long.Long;
				multiply: (multiplier: string | number | Long.Long) => Long.Long;
				mul: (multiplier: string | number | Long.Long) => Long.Long;
				negate: () => Long.Long;
				neg: () => Long.Long;
				not: () => Long.Long;
				notEquals: (other: string | number | Long.Long) => boolean;
				neq: (other: string | number | Long.Long) => boolean;
				or: (other: string | number | Long.Long) => Long.Long;
				shiftLeft: (numBits: number | Long.Long) => Long.Long;
				shl: (numBits: number | Long.Long) => Long.Long;
				shiftRight: (numBits: number | Long.Long) => Long.Long;
				shr: (numBits: number | Long.Long) => Long.Long;
				shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
				shru: (numBits: number | Long.Long) => Long.Long;
				subtract: (subtrahend: string | number | Long.Long) => Long.Long;
				sub: (subtrahend: string | number | Long.Long) => Long.Long;
				toInt: () => number;
				toNumber: () => number;
				toBytes: (le?: boolean) => number[];
				toBytesLE: () => number[];
				toBytesBE: () => number[];
				toSigned: () => Long.Long;
				toString: (radix?: number) => string;
				toUnsigned: () => Long.Long;
				xor: (other: string | number | Long.Long) => Long.Long;
			} & Record<Exclude<keyof I["pagination"]["limit"], keyof Long.Long>, never>);
			countTotal?: boolean;
			reverse?: boolean;
		} & Record<Exclude<keyof I["pagination"], keyof PageRequest>, never>;
	} & Record<Exclude<keyof I, "pagination">, never>>(object: I): QueryDenomsMetadataRequest;
};
declare const QueryDenomsMetadataResponse: {
	encode(message: QueryDenomsMetadataResponse, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryDenomsMetadataResponse;
	fromJSON(object: any): QueryDenomsMetadataResponse;
	toJSON(message: QueryDenomsMetadataResponse): unknown;
	fromPartial<I extends {
		metadatas?: {
			description?: string;
			denomUnits?: {
				denom?: string;
				exponent?: number;
				aliases?: string[];
			}[];
			base?: string;
			display?: string;
			name?: string;
			symbol?: string;
		}[];
		pagination?: {
			nextKey?: Uint8Array;
			total?: string | number | Long.Long;
		};
	} & {
		metadatas?: {
			description?: string;
			denomUnits?: {
				denom?: string;
				exponent?: number;
				aliases?: string[];
			}[];
			base?: string;
			display?: string;
			name?: string;
			symbol?: string;
		}[] & ({
			description?: string;
			denomUnits?: {
				denom?: string;
				exponent?: number;
				aliases?: string[];
			}[];
			base?: string;
			display?: string;
			name?: string;
			symbol?: string;
		} & {
			description?: string;
			denomUnits?: {
				denom?: string;
				exponent?: number;
				aliases?: string[];
			}[] & ({
				denom?: string;
				exponent?: number;
				aliases?: string[];
			} & {
				denom?: string;
				exponent?: number;
				aliases?: string[] & string[] & Record<Exclude<keyof I["metadatas"][number]["denomUnits"][number]["aliases"], keyof string[]>, never>;
			} & Record<Exclude<keyof I["metadatas"][number]["denomUnits"][number], keyof DenomUnit>, never>)[] & Record<Exclude<keyof I["metadatas"][number]["denomUnits"], keyof {
				denom?: string;
				exponent?: number;
				aliases?: string[];
			}[]>, never>;
			base?: string;
			display?: string;
			name?: string;
			symbol?: string;
		} & Record<Exclude<keyof I["metadatas"][number], keyof Metadata>, never>)[] & Record<Exclude<keyof I["metadatas"], keyof {
			description?: string;
			denomUnits?: {
				denom?: string;
				exponent?: number;
				aliases?: string[];
			}[];
			base?: string;
			display?: string;
			name?: string;
			symbol?: string;
		}[]>, never>;
		pagination?: {
			nextKey?: Uint8Array;
			total?: string | number | Long.Long;
		} & {
			nextKey?: Uint8Array;
			total?: string | number | (Long.Long & {
				high: number;
				low: number;
				unsigned: boolean;
				add: (addend: string | number | Long.Long) => Long.Long;
				and: (other: string | number | Long.Long) => Long.Long;
				compare: (other: string | number | Long.Long) => number;
				comp: (other: string | number | Long.Long) => number;
				divide: (divisor: string | number | Long.Long) => Long.Long;
				div: (divisor: string | number | Long.Long) => Long.Long;
				equals: (other: string | number | Long.Long) => boolean;
				eq: (other: string | number | Long.Long) => boolean;
				getHighBits: () => number;
				getHighBitsUnsigned: () => number;
				getLowBits: () => number;
				getLowBitsUnsigned: () => number;
				getNumBitsAbs: () => number;
				greaterThan: (other: string | number | Long.Long) => boolean;
				gt: (other: string | number | Long.Long) => boolean;
				greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
				gte: (other: string | number | Long.Long) => boolean;
				isEven: () => boolean;
				isNegative: () => boolean;
				isOdd: () => boolean;
				isPositive: () => boolean;
				isZero: () => boolean;
				lessThan: (other: string | number | Long.Long) => boolean;
				lt: (other: string | number | Long.Long) => boolean;
				lessThanOrEqual: (other: string | number | Long.Long) => boolean;
				lte: (other: string | number | Long.Long) => boolean;
				modulo: (other: string | number | Long.Long) => Long.Long;
				mod: (other: string | number | Long.Long) => Long.Long;
				multiply: (multiplier: string | number | Long.Long) => Long.Long;
				mul: (multiplier: string | number | Long.Long) => Long.Long;
				negate: () => Long.Long;
				neg: () => Long.Long;
				not: () => Long.Long;
				notEquals: (other: string | number | Long.Long) => boolean;
				neq: (other: string | number | Long.Long) => boolean;
				or: (other: string | number | Long.Long) => Long.Long;
				shiftLeft: (numBits: number | Long.Long) => Long.Long;
				shl: (numBits: number | Long.Long) => Long.Long;
				shiftRight: (numBits: number | Long.Long) => Long.Long;
				shr: (numBits: number | Long.Long) => Long.Long;
				shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
				shru: (numBits: number | Long.Long) => Long.Long;
				subtract: (subtrahend: string | number | Long.Long) => Long.Long;
				sub: (subtrahend: string | number | Long.Long) => Long.Long;
				toInt: () => number;
				toNumber: () => number;
				toBytes: (le?: boolean) => number[];
				toBytesLE: () => number[];
				toBytesBE: () => number[];
				toSigned: () => Long.Long;
				toString: (radix?: number) => string;
				toUnsigned: () => Long.Long;
				xor: (other: string | number | Long.Long) => Long.Long;
			} & Record<Exclude<keyof I["pagination"]["total"], keyof Long.Long>, never>);
		} & Record<Exclude<keyof I["pagination"], keyof PageResponse>, never>;
	} & Record<Exclude<keyof I, keyof QueryDenomsMetadataResponse>, never>>(object: I): QueryDenomsMetadataResponse;
};
declare const QueryDenomMetadataRequest: {
	encode(message: QueryDenomMetadataRequest, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryDenomMetadataRequest;
	fromJSON(object: any): QueryDenomMetadataRequest;
	toJSON(message: QueryDenomMetadataRequest): unknown;
	fromPartial<I extends {
		denom?: string;
	} & {
		denom?: string;
	} & Record<Exclude<keyof I, "denom">, never>>(object: I): QueryDenomMetadataRequest;
};
declare const QueryDenomMetadataResponse: {
	encode(message: QueryDenomMetadataResponse, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryDenomMetadataResponse;
	fromJSON(object: any): QueryDenomMetadataResponse;
	toJSON(message: QueryDenomMetadataResponse): unknown;
	fromPartial<I extends {
		metadata?: {
			description?: string;
			denomUnits?: {
				denom?: string;
				exponent?: number;
				aliases?: string[];
			}[];
			base?: string;
			display?: string;
			name?: string;
			symbol?: string;
		};
	} & {
		metadata?: {
			description?: string;
			denomUnits?: {
				denom?: string;
				exponent?: number;
				aliases?: string[];
			}[];
			base?: string;
			display?: string;
			name?: string;
			symbol?: string;
		} & {
			description?: string;
			denomUnits?: {
				denom?: string;
				exponent?: number;
				aliases?: string[];
			}[] & ({
				denom?: string;
				exponent?: number;
				aliases?: string[];
			} & {
				denom?: string;
				exponent?: number;
				aliases?: string[] & string[] & Record<Exclude<keyof I["metadata"]["denomUnits"][number]["aliases"], keyof string[]>, never>;
			} & Record<Exclude<keyof I["metadata"]["denomUnits"][number], keyof DenomUnit>, never>)[] & Record<Exclude<keyof I["metadata"]["denomUnits"], keyof {
				denom?: string;
				exponent?: number;
				aliases?: string[];
			}[]>, never>;
			base?: string;
			display?: string;
			name?: string;
			symbol?: string;
		} & Record<Exclude<keyof I["metadata"], keyof Metadata>, never>;
	} & Record<Exclude<keyof I, "metadata">, never>>(object: I): QueryDenomMetadataResponse;
};
/** Query defines the gRPC querier service. */
export interface Query {
	/** Balance queries the balance of a single coin for a single account. */
	Balance(request: QueryBalanceRequest): Promise<QueryBalanceResponse>;
	/** AllBalances queries the balance of all coins for a single account. */
	AllBalances(request: QueryAllBalancesRequest): Promise<QueryAllBalancesResponse>;
	/** TotalSupply queries the total supply of all coins. */
	TotalSupply(request: QueryTotalSupplyRequest): Promise<QueryTotalSupplyResponse>;
	/** SupplyOf queries the supply of a single coin. */
	SupplyOf(request: QuerySupplyOfRequest): Promise<QuerySupplyOfResponse>;
	/** Params queries the parameters of x/bank module. */
	Params(request: QueryParamsRequest): Promise<QueryParamsResponse>;
	/** DenomsMetadata queries the client metadata of a given coin denomination. */
	DenomMetadata(request: QueryDenomMetadataRequest): Promise<QueryDenomMetadataResponse>;
	/** DenomsMetadata queries the client metadata for all registered coin denominations. */
	DenomsMetadata(request: QueryDenomsMetadataRequest): Promise<QueryDenomsMetadataResponse>;
}
declare class QueryClientImpl implements Query {
	private readonly rpc;
	constructor(rpc: Rpc);
	Balance(request: QueryBalanceRequest): Promise<QueryBalanceResponse>;
	AllBalances(request: QueryAllBalancesRequest): Promise<QueryAllBalancesResponse>;
	TotalSupply(request: QueryTotalSupplyRequest): Promise<QueryTotalSupplyResponse>;
	SupplyOf(request: QuerySupplyOfRequest): Promise<QuerySupplyOfResponse>;
	Params(request: QueryParamsRequest): Promise<QueryParamsResponse>;
	DenomMetadata(request: QueryDenomMetadataRequest): Promise<QueryDenomMetadataResponse>;
	DenomsMetadata(request: QueryDenomsMetadataRequest): Promise<QueryDenomsMetadataResponse>;
}
export interface Rpc {
	request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}
/** Params defines the parameters for the module. */
export interface Params {
	testnet: string;
}
declare const Params: {
	encode(message: Params, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): Params;
	fromJSON(object: any): Params;
	toJSON(message: Params): unknown;
	fromPartial<I extends {
		testnet?: string;
	} & {
		testnet?: string;
	} & Record<Exclude<keyof I, "testnet">, never>>(object: I): Params;
};
/** QueryParamsRequest is request type for the Query/Params RPC method. */
export interface QueryParamsRequest {
}
/** QueryParamsResponse is response type for the Query/Params RPC method. */
export interface QueryParamsResponse {
	/** params holds all the parameters of this module. */
	params?: Params;
}
export interface QueryMintRequest {
	address: string;
}
export interface QueryMintResponse {
	address: string;
	mnemonic: string;
}
declare const QueryParamsRequest: {
	encode(_: QueryParamsRequest, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryParamsRequest;
	fromJSON(_: any): QueryParamsRequest;
	toJSON(_: QueryParamsRequest): unknown;
	fromPartial<I extends {} & {} & Record<Exclude<keyof I, never>, never>>(_: I): QueryParamsRequest;
};
declare const QueryParamsResponse: {
	encode(message: QueryParamsResponse, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryParamsResponse;
	fromJSON(object: any): QueryParamsResponse;
	toJSON(message: QueryParamsResponse): unknown;
	fromPartial<I extends {
		params?: {
			testnet?: string;
		};
	} & {
		params?: {
			testnet?: string;
		} & {
			testnet?: string;
		} & Record<Exclude<keyof I["params"], "testnet">, never>;
	} & Record<Exclude<keyof I, "params">, never>>(object: I): QueryParamsResponse;
};
declare const QueryMintRequest: {
	encode(message: QueryMintRequest, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryMintRequest;
	fromJSON(object: any): QueryMintRequest;
	toJSON(message: QueryMintRequest): unknown;
	fromPartial<I extends {
		address?: string;
	} & {
		address?: string;
	} & Record<Exclude<keyof I, "address">, never>>(object: I): QueryMintRequest;
};
declare const QueryMintResponse: {
	encode(message: QueryMintResponse, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryMintResponse;
	fromJSON(object: any): QueryMintResponse;
	toJSON(message: QueryMintResponse): unknown;
	fromPartial<I extends {
		address?: string;
		mnemonic?: string;
	} & {
		address?: string;
		mnemonic?: string;
	} & Record<Exclude<keyof I, keyof QueryMintResponse>, never>>(object: I): QueryMintResponse;
};
/** Query defines the gRPC querier service. */
export interface Query {
	/** Parameters queries the parameters of the module. */
	Params(request: QueryParamsRequest): Promise<QueryParamsResponse>;
	/** Queries a list of Mint items. */
	Mint(request: QueryMintRequest): Promise<QueryMintResponse>;
}
declare class QueryClientImpl implements Query {
	private readonly rpc;
	constructor(rpc: Rpc);
	Params(request: QueryParamsRequest): Promise<QueryParamsResponse>;
	Mint(request: QueryMintRequest): Promise<QueryMintResponse>;
}
export interface Rpc {
	request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}
export interface QueryGetTaxInfoRequest {
}
export interface QueryGetTaxInfoResponse {
	gasTaxBp: Long;
	transferTaxBp: Long;
	taxCollector: string;
}
declare const QueryGetTaxInfoRequest: {
	encode(_: QueryGetTaxInfoRequest, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryGetTaxInfoRequest;
	fromJSON(_: any): QueryGetTaxInfoRequest;
	toJSON(_: QueryGetTaxInfoRequest): unknown;
	fromPartial<I extends {} & {} & Record<Exclude<keyof I, never>, never>>(_: I): QueryGetTaxInfoRequest;
};
declare const QueryGetTaxInfoResponse: {
	encode(message: QueryGetTaxInfoResponse, writer?: _m0.Writer): _m0.Writer;
	decode(input: _m0.Reader | Uint8Array, length?: number): QueryGetTaxInfoResponse;
	fromJSON(object: any): QueryGetTaxInfoResponse;
	toJSON(message: QueryGetTaxInfoResponse): unknown;
	fromPartial<I extends {
		gasTaxBp?: string | number | Long.Long;
		transferTaxBp?: string | number | Long.Long;
		taxCollector?: string;
	} & {
		gasTaxBp?: string | number | (Long.Long & {
			high: number;
			low: number;
			unsigned: boolean;
			add: (addend: string | number | Long.Long) => Long.Long;
			and: (other: string | number | Long.Long) => Long.Long;
			compare: (other: string | number | Long.Long) => number;
			comp: (other: string | number | Long.Long) => number;
			divide: (divisor: string | number | Long.Long) => Long.Long;
			div: (divisor: string | number | Long.Long) => Long.Long;
			equals: (other: string | number | Long.Long) => boolean;
			eq: (other: string | number | Long.Long) => boolean;
			getHighBits: () => number;
			getHighBitsUnsigned: () => number;
			getLowBits: () => number;
			getLowBitsUnsigned: () => number;
			getNumBitsAbs: () => number;
			greaterThan: (other: string | number | Long.Long) => boolean;
			gt: (other: string | number | Long.Long) => boolean;
			greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
			gte: (other: string | number | Long.Long) => boolean;
			isEven: () => boolean;
			isNegative: () => boolean;
			isOdd: () => boolean;
			isPositive: () => boolean;
			isZero: () => boolean;
			lessThan: (other: string | number | Long.Long) => boolean;
			lt: (other: string | number | Long.Long) => boolean;
			lessThanOrEqual: (other: string | number | Long.Long) => boolean;
			lte: (other: string | number | Long.Long) => boolean;
			modulo: (other: string | number | Long.Long) => Long.Long;
			mod: (other: string | number | Long.Long) => Long.Long;
			multiply: (multiplier: string | number | Long.Long) => Long.Long;
			mul: (multiplier: string | number | Long.Long) => Long.Long;
			negate: () => Long.Long;
			neg: () => Long.Long;
			not: () => Long.Long;
			notEquals: (other: string | number | Long.Long) => boolean;
			neq: (other: string | number | Long.Long) => boolean;
			or: (other: string | number | Long.Long) => Long.Long;
			shiftLeft: (numBits: number | Long.Long) => Long.Long;
			shl: (numBits: number | Long.Long) => Long.Long;
			shiftRight: (numBits: number | Long.Long) => Long.Long;
			shr: (numBits: number | Long.Long) => Long.Long;
			shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
			shru: (numBits: number | Long.Long) => Long.Long;
			subtract: (subtrahend: string | number | Long.Long) => Long.Long;
			sub: (subtrahend: string | number | Long.Long) => Long.Long;
			toInt: () => number;
			toNumber: () => number;
			toBytes: (le?: boolean) => number[];
			toBytesLE: () => number[];
			toBytesBE: () => number[];
			toSigned: () => Long.Long;
			toString: (radix?: number) => string;
			toUnsigned: () => Long.Long;
			xor: (other: string | number | Long.Long) => Long.Long;
		} & Record<Exclude<keyof I["gasTaxBp"], keyof Long.Long>, never>);
		transferTaxBp?: string | number | (Long.Long & {
			high: number;
			low: number;
			unsigned: boolean;
			add: (addend: string | number | Long.Long) => Long.Long;
			and: (other: string | number | Long.Long) => Long.Long;
			compare: (other: string | number | Long.Long) => number;
			comp: (other: string | number | Long.Long) => number;
			divide: (divisor: string | number | Long.Long) => Long.Long;
			div: (divisor: string | number | Long.Long) => Long.Long;
			equals: (other: string | number | Long.Long) => boolean;
			eq: (other: string | number | Long.Long) => boolean;
			getHighBits: () => number;
			getHighBitsUnsigned: () => number;
			getLowBits: () => number;
			getLowBitsUnsigned: () => number;
			getNumBitsAbs: () => number;
			greaterThan: (other: string | number | Long.Long) => boolean;
			gt: (other: string | number | Long.Long) => boolean;
			greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
			gte: (other: string | number | Long.Long) => boolean;
			isEven: () => boolean;
			isNegative: () => boolean;
			isOdd: () => boolean;
			isPositive: () => boolean;
			isZero: () => boolean;
			lessThan: (other: string | number | Long.Long) => boolean;
			lt: (other: string | number | Long.Long) => boolean;
			lessThanOrEqual: (other: string | number | Long.Long) => boolean;
			lte: (other: string | number | Long.Long) => boolean;
			modulo: (other: string | number | Long.Long) => Long.Long;
			mod: (other: string | number | Long.Long) => Long.Long;
			multiply: (multiplier: string | number | Long.Long) => Long.Long;
			mul: (multiplier: string | number | Long.Long) => Long.Long;
			negate: () => Long.Long;
			neg: () => Long.Long;
			not: () => Long.Long;
			notEquals: (other: string | number | Long.Long) => boolean;
			neq: (other: string | number | Long.Long) => boolean;
			or: (other: string | number | Long.Long) => Long.Long;
			shiftLeft: (numBits: number | Long.Long) => Long.Long;
			shl: (numBits: number | Long.Long) => Long.Long;
			shiftRight: (numBits: number | Long.Long) => Long.Long;
			shr: (numBits: number | Long.Long) => Long.Long;
			shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
			shru: (numBits: number | Long.Long) => Long.Long;
			subtract: (subtrahend: string | number | Long.Long) => Long.Long;
			sub: (subtrahend: string | number | Long.Long) => Long.Long;
			toInt: () => number;
			toNumber: () => number;
			toBytes: (le?: boolean) => number[];
			toBytesLE: () => number[];
			toBytesBE: () => number[];
			toSigned: () => Long.Long;
			toString: (radix?: number) => string;
			toUnsigned: () => Long.Long;
			xor: (other: string | number | Long.Long) => Long.Long;
		} & Record<Exclude<keyof I["transferTaxBp"], keyof Long.Long>, never>);
		taxCollector?: string;
	} & Record<Exclude<keyof I, keyof QueryGetTaxInfoResponse>, never>>(object: I): QueryGetTaxInfoResponse;
};
/** Query defines the gRPC querier service. */
export interface Query {
	/** Queries a list of GetTaxInfo items. */
	GetTaxInfo(request: QueryGetTaxInfoRequest): Promise<QueryGetTaxInfoResponse>;
}
declare class QueryClientImpl implements Query {
	private readonly rpc;
	constructor(rpc: Rpc);
	GetTaxInfo(request: QueryGetTaxInfoRequest): Promise<QueryGetTaxInfoResponse>;
}
export interface Rpc {
	request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}
/**
 * PageRequest is to be embedded in gRPC request messages for efficient
 * pagination. Ex:
 *
 *  message SomeRequest {
 *          Foo some_parameter = 1;
 *          PageRequest pagination = 2;
 *  }
 */
export interface PageRequest {
	/**
	 * key is a value returned in PageResponse.next_key to begin
	 * querying the next page most efficiently. Only one of offset or key
	 * should be set.
	 */
	key: Uint8Array;
	/**
	 * offset is a numeric offset that can be used when key is unavailable.
	 * It is less efficient than using key. Only one of offset or key should
	 * be set.
	 */
	offset: number;
	/**
	 * limit is the total number of results to be returned in the result page.
	 * If left empty it will default to a value to be set by each app.
	 */
	limit: number;
	/**
	 * count_total is set to true  to indicate that the result set should include
	 * a count of the total number of items available for pagination in UIs.
	 * count_total is only respected when offset is used. It is ignored when key
	 * is set.
	 */
	count_total: boolean;
	/** reverse is set to true if results are to be returned in the descending order. */
	reverse: boolean;
}
/**
 * PageResponse is to be embedded in gRPC response messages where the
 * corresponding request message has used PageRequest.
 *
 *  message SomeResponse {
 *          repeated Bar results = 1;
 *          PageResponse page = 2;
 *  }
 */
export interface PageResponse {
	/**
	 * next_key is the key to be passed to PageRequest.key to
	 * query the next page most efficiently
	 */
	next_key: Uint8Array;
	/**
	 * total is total number of results available if PageRequest.count_total
	 * was set, its value is undefined otherwise
	 */
	total: number;
}
declare const PageRequest: {
	encode(message: PageRequest, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): PageRequest;
	fromJSON(object: any): PageRequest;
	toJSON(message: PageRequest): unknown;
	fromPartial(object: DeepPartial<PageRequest>): PageRequest;
};
declare const PageResponse: {
	encode(message: PageResponse, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): PageResponse;
	fromJSON(object: any): PageResponse;
	toJSON(message: PageResponse): unknown;
	fromPartial(object: DeepPartial<PageResponse>): PageResponse;
};
export declare type Builtin = Date | Function | Uint8Array | string | number | undefined;
export declare type DeepPartial<T> = T extends Builtin ? T : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {} ? {
	[K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
/**
 * Consensus captures the consensus rules for processing a block in the blockchain,
 * including all blockchain data structures and the rules of the application's
 * state transition machine.
 */
export interface Consensus {
	block: number;
	app: number;
}
declare const Consensus: {
	encode(message: Consensus, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): Consensus;
	fromJSON(object: any): Consensus;
	toJSON(message: Consensus): unknown;
	fromPartial(object: DeepPartial<Consensus>): Consensus;
};
export declare type Builtin = Date | Function | Uint8Array | string | number | undefined;
export declare type DeepPartial<T> = T extends Builtin ? T : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {} ? {
	[K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
/** PartsetHeader */
export interface PartSetHeader {
	total: number;
	hash: Uint8Array;
}
/** BlockID */
export interface BlockID {
	hash: Uint8Array;
	part_set_header: PartSetHeader | undefined;
}
/** Header defines the structure of a Tendermint block header. */
export interface Header {
	/** basic block info */
	version: Consensus | undefined;
	chain_id: string;
	height: number;
	time: Date | undefined;
	/** prev block info */
	last_block_id: BlockID | undefined;
	/** hashes of block data */
	last_commit_hash: Uint8Array;
	/** transactions */
	data_hash: Uint8Array;
	/** hashes from the app output from the prev block */
	validators_hash: Uint8Array;
	/** validators for the next block */
	next_validators_hash: Uint8Array;
	/** consensus params for current block */
	consensus_hash: Uint8Array;
	/** state after txs from the previous block */
	app_hash: Uint8Array;
	/** root hash of all results from the txs from the previous block */
	last_results_hash: Uint8Array;
	/** consensus info */
	evidence_hash: Uint8Array;
	/** original proposer of the block */
	proposer_address: Uint8Array;
}
declare const PartSetHeader: {
	encode(message: PartSetHeader, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): PartSetHeader;
	fromJSON(object: any): PartSetHeader;
	toJSON(message: PartSetHeader): unknown;
	fromPartial(object: DeepPartial<PartSetHeader>): PartSetHeader;
};
declare const BlockID: {
	encode(message: BlockID, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): BlockID;
	fromJSON(object: any): BlockID;
	toJSON(message: BlockID): unknown;
	fromPartial(object: DeepPartial<BlockID>): BlockID;
};
declare const Header: {
	encode(message: Header, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): Header;
	fromJSON(object: any): Header;
	toJSON(message: Header): unknown;
	fromPartial(object: DeepPartial<Header>): Header;
};
export declare type Builtin = Date | Function | Uint8Array | string | number | undefined;
export declare type DeepPartial<T> = T extends Builtin ? T : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {} ? {
	[K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
/**
 * `Any` contains an arbitrary serialized protocol buffer message along with a
 * URL that describes the type of the serialized message.
 *
 * Protobuf library provides support to pack/unpack Any values in the form
 * of utility functions or additional generated methods of the Any type.
 *
 * Example 1: Pack and unpack a message in C++.
 *
 *     Foo foo = ...;
 *     Any any;
 *     any.PackFrom(foo);
 *     ...
 *     if (any.UnpackTo(&foo)) {
 *       ...
 *     }
 *
 * Example 2: Pack and unpack a message in Java.
 *
 *     Foo foo = ...;
 *     Any any = Any.pack(foo);
 *     ...
 *     if (any.is(Foo.class)) {
 *       foo = any.unpack(Foo.class);
 *     }
 *
 *  Example 3: Pack and unpack a message in Python.
 *
 *     foo = Foo(...)
 *     any = Any()
 *     any.Pack(foo)
 *     ...
 *     if any.Is(Foo.DESCRIPTOR):
 *       any.Unpack(foo)
 *       ...
 *
 *  Example 4: Pack and unpack a message in Go
 *
 *      foo := &pb.Foo{...}
 *      any, err := anypb.New(foo)
 *      if err != nil {
 *        ...
 *      }
 *      ...
 *      foo := &pb.Foo{}
 *      if err := any.UnmarshalTo(foo); err != nil {
 *        ...
 *      }
 *
 * The pack methods provided by protobuf library will by default use
 * 'type.googleapis.com/full.type.name' as the type URL and the unpack
 * methods only use the fully qualified type name after the last '/'
 * in the type URL, for example "foo.bar.com/x/y.z" will yield type
 * name "y.z".
 *
 *
 * JSON
 * ====
 * The JSON representation of an `Any` value uses the regular
 * representation of the deserialized, embedded message, with an
 * additional field `@type` which contains the type URL. Example:
 *
 *     package google.profile;
 *     message Person {
 *       string first_name = 1;
 *       string last_name = 2;
 *     }
 *
 *     {
 *       "@type": "type.googleapis.com/google.profile.Person",
 *       "firstName": <string>,
 *       "lastName": <string>
 *     }
 *
 * If the embedded message type is well-known and has a custom JSON
 * representation, that representation will be embedded adding a field
 * `value` which holds the custom JSON in addition to the `@type`
 * field. Example (for message [google.protobuf.Duration][]):
 *
 *     {
 *       "@type": "type.googleapis.com/google.protobuf.Duration",
 *       "value": "1.212s"
 *     }
 */
export interface Any {
	/**
	 * A URL/resource name that uniquely identifies the type of the serialized
	 * protocol buffer message. This string must contain at least
	 * one "/" character. The last segment of the URL's path must represent
	 * the fully qualified name of the type (as in
	 * `path/google.protobuf.Duration`). The name should be in a canonical form
	 * (e.g., leading "." is not accepted).
	 *
	 * In practice, teams usually precompile into the binary all types that they
	 * expect it to use in the context of Any. However, for URLs which use the
	 * scheme `http`, `https`, or no scheme, one can optionally set up a type
	 * server that maps type URLs to message definitions as follows:
	 *
	 * * If no scheme is provided, `https` is assumed.
	 * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
	 *   value in binary format, or produce an error.
	 * * Applications are allowed to cache lookup results based on the
	 *   URL, or have them precompiled into a binary to avoid any
	 *   lookup. Therefore, binary compatibility needs to be preserved
	 *   on changes to types. (Use versioned type names to manage
	 *   breaking changes.)
	 *
	 * Note: this functionality is not currently available in the official
	 * protobuf release, and it is not used for type URLs beginning with
	 * type.googleapis.com.
	 *
	 * Schemes other than `http`, `https` (or the empty scheme) might be
	 * used with implementation specific semantics.
	 */
	type_url: string;
	/** Must be a valid serialized protocol buffer of the above specified type. */
	value: Uint8Array;
}
declare const Any: {
	encode(message: Any, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): Any;
	fromJSON(object: any): Any;
	toJSON(message: Any): unknown;
	fromPartial(object: DeepPartial<Any>): Any;
};
export declare type Builtin = Date | Function | Uint8Array | string | number | undefined;
export declare type DeepPartial<T> = T extends Builtin ? T : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {} ? {
	[K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
/**
 * A Duration represents a signed, fixed-length span of time represented
 * as a count of seconds and fractions of seconds at nanosecond
 * resolution. It is independent of any calendar and concepts like "day"
 * or "month". It is related to Timestamp in that the difference between
 * two Timestamp values is a Duration and it can be added or subtracted
 * from a Timestamp. Range is approximately +-10,000 years.
 *
 * # Examples
 *
 * Example 1: Compute Duration from two Timestamps in pseudo code.
 *
 *     Timestamp start = ...;
 *     Timestamp end = ...;
 *     Duration duration = ...;
 *
 *     duration.seconds = end.seconds - start.seconds;
 *     duration.nanos = end.nanos - start.nanos;
 *
 *     if (duration.seconds < 0 && duration.nanos > 0) {
 *       duration.seconds += 1;
 *       duration.nanos -= 1000000000;
 *     } else if (duration.seconds > 0 && duration.nanos < 0) {
 *       duration.seconds -= 1;
 *       duration.nanos += 1000000000;
 *     }
 *
 * Example 2: Compute Timestamp from Timestamp + Duration in pseudo code.
 *
 *     Timestamp start = ...;
 *     Duration duration = ...;
 *     Timestamp end = ...;
 *
 *     end.seconds = start.seconds + duration.seconds;
 *     end.nanos = start.nanos + duration.nanos;
 *
 *     if (end.nanos < 0) {
 *       end.seconds -= 1;
 *       end.nanos += 1000000000;
 *     } else if (end.nanos >= 1000000000) {
 *       end.seconds += 1;
 *       end.nanos -= 1000000000;
 *     }
 *
 * Example 3: Compute Duration from datetime.timedelta in Python.
 *
 *     td = datetime.timedelta(days=3, minutes=10)
 *     duration = Duration()
 *     duration.FromTimedelta(td)
 *
 * # JSON Mapping
 *
 * In JSON format, the Duration type is encoded as a string rather than an
 * object, where the string ends in the suffix "s" (indicating seconds) and
 * is preceded by the number of seconds, with nanoseconds expressed as
 * fractional seconds. For example, 3 seconds with 0 nanoseconds should be
 * encoded in JSON format as "3s", while 3 seconds and 1 nanosecond should
 * be expressed in JSON format as "3.000000001s", and 3 seconds and 1
 * microsecond should be expressed in JSON format as "3.000001s".
 */
export interface Duration {
	/**
	 * Signed seconds of the span of time. Must be from -315,576,000,000
	 * to +315,576,000,000 inclusive. Note: these bounds are computed from:
	 * 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
	 */
	seconds: number;
	/**
	 * Signed fractions of a second at nanosecond resolution of the span
	 * of time. Durations less than one second are represented with a 0
	 * `seconds` field and a positive or negative `nanos` field. For durations
	 * of one second or more, a non-zero value for the `nanos` field must be
	 * of the same sign as the `seconds` field. Must be from -999,999,999
	 * to +999,999,999 inclusive.
	 */
	nanos: number;
}
declare const Duration: {
	encode(message: Duration, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): Duration;
	fromJSON(object: any): Duration;
	toJSON(message: Duration): unknown;
	fromPartial(object: DeepPartial<Duration>): Duration;
};
export declare type Builtin = Date | Function | Uint8Array | string | number | undefined;
export declare type DeepPartial<T> = T extends Builtin ? T : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {} ? {
	[K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
/**
 * Coin defines a token with a denomination and an amount.
 *
 * NOTE: The amount field is an Int which implements the custom method
 * signatures required by gogoproto.
 */
export interface Coin {
	denom: string;
	amount: string;
}
declare const Coin: {
	encode(message: Coin, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): Coin;
	fromJSON(object: any): Coin;
	toJSON(message: Coin): unknown;
	fromPartial(object: DeepPartial<Coin>): Coin;
};
export declare type Builtin = Date | Function | Uint8Array | string | number | undefined;
export declare type DeepPartial<T> = T extends Builtin ? T : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {} ? {
	[K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
declare enum BondStatus {
	/** BOND_STATUS_UNSPECIFIED - UNSPECIFIED defines an invalid validator status. */
	BOND_STATUS_UNSPECIFIED = 0,
	/** BOND_STATUS_UNBONDED - UNBONDED defines a validator that is not bonded. */
	BOND_STATUS_UNBONDED = 1,
	/** BOND_STATUS_UNBONDING - UNBONDING defines a validator that is unbonding. */
	BOND_STATUS_UNBONDING = 2,
	/** BOND_STATUS_BONDED - BONDED defines a validator that is bonded. */
	BOND_STATUS_BONDED = 3,
	UNRECOGNIZED = -1
}
/**
 * HistoricalInfo contains header and validator information for a given block.
 * It is stored as part of staking module's state, which persists the `n` most
 * recent HistoricalInfo
 * (`n` is set by the staking module's `historical_entries` parameter).
 */
export interface HistoricalInfo {
	header: Header | undefined;
	valset: Validator[];
}
/**
 * CommissionRates defines the initial commission rates to be used for creating
 * a validator.
 */
export interface CommissionRates {
	/** rate is the commission rate charged to delegators, as a fraction. */
	rate: string;
	/** max_rate defines the maximum commission rate which validator can ever charge, as a fraction. */
	max_rate: string;
	/** max_change_rate defines the maximum daily increase of the validator commission, as a fraction. */
	max_change_rate: string;
}
/** Commission defines commission parameters for a given validator. */
export interface Commission {
	/** commission_rates defines the initial commission rates to be used for creating a validator. */
	commission_rates: CommissionRates | undefined;
	/** update_time is the last time the commission rate was changed. */
	update_time: Date | undefined;
}
/** Description defines a validator description. */
export interface Description {
	/** moniker defines a human-readable name for the validator. */
	moniker: string;
	/** identity defines an optional identity signature (ex. UPort or Keybase). */
	identity: string;
	/** website defines an optional website link. */
	website: string;
	/** security_contact defines an optional email for security contact. */
	security_contact: string;
	/** details define other optional details. */
	details: string;
}
/**
 * Validator defines a validator, together with the total amount of the
 * Validator's bond shares and their exchange rate to coins. Slashing results in
 * a decrease in the exchange rate, allowing correct calculation of future
 * undelegations without iterating over delegators. When coins are delegated to
 * this validator, the validator is credited with a delegation whose number of
 * bond shares is based on the amount of coins delegated divided by the current
 * exchange rate. Voting power can be calculated as total bonded shares
 * multiplied by exchange rate.
 */
export interface Validator {
	/** operator_address defines the address of the validator's operator; bech encoded in JSON. */
	operator_address: string;
	/** consensus_pubkey is the consensus public key of the validator, as a Protobuf Any. */
	consensus_pubkey: Any | undefined;
	/** jailed defined whether the validator has been jailed from bonded status or not. */
	jailed: boolean;
	/** status is the validator status (bonded/unbonding/unbonded). */
	status: BondStatus;
	/** tokens define the delegated tokens (incl. self-delegation). */
	tokens: string;
	/** delegator_shares defines total shares issued to a validator's delegators. */
	delegator_shares: string;
	/** description defines the description terms for the validator. */
	description: Description | undefined;
	/** unbonding_height defines, if unbonding, the height at which this validator has begun unbonding. */
	unbonding_height: number;
	/** unbonding_time defines, if unbonding, the min time for the validator to complete unbonding. */
	unbonding_time: Date | undefined;
	/** commission defines the commission parameters. */
	commission: Commission | undefined;
	/** min_self_delegation is the validator's self declared minimum self delegation. */
	min_self_delegation: string;
}
/**
 * Delegation represents the bond with tokens held by an account. It is
 * owned by one delegator, and is associated with the voting power of one
 * validator.
 */
export interface Delegation {
	/** delegator_address is the bech32-encoded address of the delegator. */
	delegator_address: string;
	/** validator_address is the bech32-encoded address of the validator. */
	validator_address: string;
	/** shares define the delegation shares received. */
	shares: string;
}
/**
 * UnbondingDelegation stores all of a single delegator's unbonding bonds
 * for a single validator in an time-ordered list.
 */
export interface UnbondingDelegation {
	/** delegator_address is the bech32-encoded address of the delegator. */
	delegator_address: string;
	/** validator_address is the bech32-encoded address of the validator. */
	validator_address: string;
	/** entries are the unbonding delegation entries. */
	entries: UnbondingDelegationEntry[];
}
/** UnbondingDelegationEntry defines an unbonding object with relevant metadata. */
export interface UnbondingDelegationEntry {
	/** creation_height is the height which the unbonding took place. */
	creation_height: number;
	/** completion_time is the unix time for unbonding completion. */
	completion_time: Date | undefined;
	/** initial_balance defines the tokens initially scheduled to receive at completion. */
	initial_balance: string;
	/** balance defines the tokens to receive at completion. */
	balance: string;
}
/** RedelegationEntry defines a redelegation object with relevant metadata. */
export interface RedelegationEntry {
	/** creation_height  defines the height which the redelegation took place. */
	creation_height: number;
	/** completion_time defines the unix time for redelegation completion. */
	completion_time: Date | undefined;
	/** initial_balance defines the initial balance when redelegation started. */
	initial_balance: string;
	/** shares_dst is the amount of destination-validator shares created by redelegation. */
	shares_dst: string;
}
/**
 * Redelegation contains the list of a particular delegator's redelegating bonds
 * from a particular source validator to a particular destination validator.
 */
export interface Redelegation {
	/** delegator_address is the bech32-encoded address of the delegator. */
	delegator_address: string;
	/** validator_src_address is the validator redelegation source operator address. */
	validator_src_address: string;
	/** validator_dst_address is the validator redelegation destination operator address. */
	validator_dst_address: string;
	/** entries are the redelegation entries. */
	entries: RedelegationEntry[];
}
/** Params defines the parameters for the staking module. */
export interface Params {
	/** unbonding_time is the time duration of unbonding. */
	unbonding_time: Duration | undefined;
	/** max_validators is the maximum number of validators. */
	max_validators: number;
	/** max_entries is the max entries for either unbonding delegation or redelegation (per pair/trio). */
	max_entries: number;
	/** historical_entries is the number of historical entries to persist. */
	historical_entries: number;
	/** bond_denom defines the bondable coin denomination. */
	bond_denom: string;
}
/**
 * DelegationResponse is equivalent to Delegation except that it contains a
 * balance in addition to shares which is more suitable for client responses.
 */
export interface DelegationResponse {
	delegation: Delegation | undefined;
	balance: Coin | undefined;
}
/**
 * RedelegationEntryResponse is equivalent to a RedelegationEntry except that it
 * contains a balance in addition to shares which is more suitable for client
 * responses.
 */
export interface RedelegationEntryResponse {
	redelegation_entry: RedelegationEntry | undefined;
	balance: string;
}
/**
 * RedelegationResponse is equivalent to a Redelegation except that its entries
 * contain a balance in addition to shares which is more suitable for client
 * responses.
 */
export interface RedelegationResponse {
	redelegation: Redelegation | undefined;
	entries: RedelegationEntryResponse[];
}
/**
 * Pool is used for tracking bonded and not-bonded token supply of the bond
 * denomination.
 */
export interface Pool {
	not_bonded_tokens: string;
	bonded_tokens: string;
}
declare const HistoricalInfo: {
	encode(message: HistoricalInfo, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): HistoricalInfo;
	fromJSON(object: any): HistoricalInfo;
	toJSON(message: HistoricalInfo): unknown;
	fromPartial(object: DeepPartial<HistoricalInfo>): HistoricalInfo;
};
declare const CommissionRates: {
	encode(message: CommissionRates, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): CommissionRates;
	fromJSON(object: any): CommissionRates;
	toJSON(message: CommissionRates): unknown;
	fromPartial(object: DeepPartial<CommissionRates>): CommissionRates;
};
declare const Commission: {
	encode(message: Commission, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): Commission;
	fromJSON(object: any): Commission;
	toJSON(message: Commission): unknown;
	fromPartial(object: DeepPartial<Commission>): Commission;
};
declare const Description: {
	encode(message: Description, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): Description;
	fromJSON(object: any): Description;
	toJSON(message: Description): unknown;
	fromPartial(object: DeepPartial<Description>): Description;
};
declare const Validator: {
	encode(message: Validator, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): Validator;
	fromJSON(object: any): Validator;
	toJSON(message: Validator): unknown;
	fromPartial(object: DeepPartial<Validator>): Validator;
};
declare const Delegation: {
	encode(message: Delegation, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): Delegation;
	fromJSON(object: any): Delegation;
	toJSON(message: Delegation): unknown;
	fromPartial(object: DeepPartial<Delegation>): Delegation;
};
declare const UnbondingDelegation: {
	encode(message: UnbondingDelegation, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): UnbondingDelegation;
	fromJSON(object: any): UnbondingDelegation;
	toJSON(message: UnbondingDelegation): unknown;
	fromPartial(object: DeepPartial<UnbondingDelegation>): UnbondingDelegation;
};
declare const UnbondingDelegationEntry: {
	encode(message: UnbondingDelegationEntry, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): UnbondingDelegationEntry;
	fromJSON(object: any): UnbondingDelegationEntry;
	toJSON(message: UnbondingDelegationEntry): unknown;
	fromPartial(object: DeepPartial<UnbondingDelegationEntry>): UnbondingDelegationEntry;
};
declare const RedelegationEntry: {
	encode(message: RedelegationEntry, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): RedelegationEntry;
	fromJSON(object: any): RedelegationEntry;
	toJSON(message: RedelegationEntry): unknown;
	fromPartial(object: DeepPartial<RedelegationEntry>): RedelegationEntry;
};
declare const Redelegation: {
	encode(message: Redelegation, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): Redelegation;
	fromJSON(object: any): Redelegation;
	toJSON(message: Redelegation): unknown;
	fromPartial(object: DeepPartial<Redelegation>): Redelegation;
};
declare const Params: {
	encode(message: Params, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): Params;
	fromJSON(object: any): Params;
	toJSON(message: Params): unknown;
	fromPartial(object: DeepPartial<Params>): Params;
};
declare const DelegationResponse: {
	encode(message: DelegationResponse, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): DelegationResponse;
	fromJSON(object: any): DelegationResponse;
	toJSON(message: DelegationResponse): unknown;
	fromPartial(object: DeepPartial<DelegationResponse>): DelegationResponse;
};
declare const RedelegationEntryResponse: {
	encode(message: RedelegationEntryResponse, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): RedelegationEntryResponse;
	fromJSON(object: any): RedelegationEntryResponse;
	toJSON(message: RedelegationEntryResponse): unknown;
	fromPartial(object: DeepPartial<RedelegationEntryResponse>): RedelegationEntryResponse;
};
declare const RedelegationResponse: {
	encode(message: RedelegationResponse, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): RedelegationResponse;
	fromJSON(object: any): RedelegationResponse;
	toJSON(message: RedelegationResponse): unknown;
	fromPartial(object: DeepPartial<RedelegationResponse>): RedelegationResponse;
};
declare const Pool: {
	encode(message: Pool, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): Pool;
	fromJSON(object: any): Pool;
	toJSON(message: Pool): unknown;
	fromPartial(object: DeepPartial<Pool>): Pool;
};
export declare type Builtin = Date | Function | Uint8Array | string | number | undefined;
export declare type DeepPartial<T> = T extends Builtin ? T : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {} ? {
	[K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
/** QueryValidatorsRequest is request type for Query/Validators RPC method. */
export interface QueryValidatorsRequest {
	/** status enables to query for validators matching a given status. */
	status: string;
	/** pagination defines an optional pagination for the request. */
	pagination: PageRequest | undefined;
}
/** QueryValidatorsResponse is response type for the Query/Validators RPC method */
export interface QueryValidatorsResponse {
	/** validators contains all the queried validators. */
	validators: Validator[];
	/** pagination defines the pagination in the response. */
	pagination: PageResponse | undefined;
}
/** QueryValidatorRequest is response type for the Query/Validator RPC method */
export interface QueryValidatorRequest {
	/** validator_addr defines the validator address to query for. */
	validator_addr: string;
}
/** QueryValidatorResponse is response type for the Query/Validator RPC method */
export interface QueryValidatorResponse {
	/** validator defines the the validator info. */
	validator: Validator | undefined;
}
/**
 * QueryValidatorDelegationsRequest is request type for the
 * Query/ValidatorDelegations RPC method
 */
export interface QueryValidatorDelegationsRequest {
	/** validator_addr defines the validator address to query for. */
	validator_addr: string;
	/** pagination defines an optional pagination for the request. */
	pagination: PageRequest | undefined;
}
/**
 * QueryValidatorDelegationsResponse is response type for the
 * Query/ValidatorDelegations RPC method
 */
export interface QueryValidatorDelegationsResponse {
	delegation_responses: DelegationResponse[];
	/** pagination defines the pagination in the response. */
	pagination: PageResponse | undefined;
}
/**
 * QueryValidatorUnbondingDelegationsRequest is required type for the
 * Query/ValidatorUnbondingDelegations RPC method
 */
export interface QueryValidatorUnbondingDelegationsRequest {
	/** validator_addr defines the validator address to query for. */
	validator_addr: string;
	/** pagination defines an optional pagination for the request. */
	pagination: PageRequest | undefined;
}
/**
 * QueryValidatorUnbondingDelegationsResponse is response type for the
 * Query/ValidatorUnbondingDelegations RPC method.
 */
export interface QueryValidatorUnbondingDelegationsResponse {
	unbonding_responses: UnbondingDelegation[];
	/** pagination defines the pagination in the response. */
	pagination: PageResponse | undefined;
}
/** QueryDelegationRequest is request type for the Query/Delegation RPC method. */
export interface QueryDelegationRequest {
	/** delegator_addr defines the delegator address to query for. */
	delegator_addr: string;
	/** validator_addr defines the validator address to query for. */
	validator_addr: string;
}
/** QueryDelegationResponse is response type for the Query/Delegation RPC method. */
export interface QueryDelegationResponse {
	/** delegation_responses defines the delegation info of a delegation. */
	delegation_response: DelegationResponse | undefined;
}
/**
 * QueryUnbondingDelegationRequest is request type for the
 * Query/UnbondingDelegation RPC method.
 */
export interface QueryUnbondingDelegationRequest {
	/** delegator_addr defines the delegator address to query for. */
	delegator_addr: string;
	/** validator_addr defines the validator address to query for. */
	validator_addr: string;
}
/**
 * QueryDelegationResponse is response type for the Query/UnbondingDelegation
 * RPC method.
 */
export interface QueryUnbondingDelegationResponse {
	/** unbond defines the unbonding information of a delegation. */
	unbond: UnbondingDelegation | undefined;
}
/**
 * QueryDelegatorDelegationsRequest is request type for the
 * Query/DelegatorDelegations RPC method.
 */
export interface QueryDelegatorDelegationsRequest {
	/** delegator_addr defines the delegator address to query for. */
	delegator_addr: string;
	/** pagination defines an optional pagination for the request. */
	pagination: PageRequest | undefined;
}
/**
 * QueryDelegatorDelegationsResponse is response type for the
 * Query/DelegatorDelegations RPC method.
 */
export interface QueryDelegatorDelegationsResponse {
	/** delegation_responses defines all the delegations' info of a delegator. */
	delegation_responses: DelegationResponse[];
	/** pagination defines the pagination in the response. */
	pagination: PageResponse | undefined;
}
/**
 * QueryDelegatorUnbondingDelegationsRequest is request type for the
 * Query/DelegatorUnbondingDelegations RPC method.
 */
export interface QueryDelegatorUnbondingDelegationsRequest {
	/** delegator_addr defines the delegator address to query for. */
	delegator_addr: string;
	/** pagination defines an optional pagination for the request. */
	pagination: PageRequest | undefined;
}
/**
 * QueryUnbondingDelegatorDelegationsResponse is response type for the
 * Query/UnbondingDelegatorDelegations RPC method.
 */
export interface QueryDelegatorUnbondingDelegationsResponse {
	unbonding_responses: UnbondingDelegation[];
	/** pagination defines the pagination in the response. */
	pagination: PageResponse | undefined;
}
/**
 * QueryRedelegationsRequest is request type for the Query/Redelegations RPC
 * method.
 */
export interface QueryRedelegationsRequest {
	/** delegator_addr defines the delegator address to query for. */
	delegator_addr: string;
	/** src_validator_addr defines the validator address to redelegate from. */
	src_validator_addr: string;
	/** dst_validator_addr defines the validator address to redelegate to. */
	dst_validator_addr: string;
	/** pagination defines an optional pagination for the request. */
	pagination: PageRequest | undefined;
}
/**
 * QueryRedelegationsResponse is response type for the Query/Redelegations RPC
 * method.
 */
export interface QueryRedelegationsResponse {
	redelegation_responses: RedelegationResponse[];
	/** pagination defines the pagination in the response. */
	pagination: PageResponse | undefined;
}
/**
 * QueryDelegatorValidatorsRequest is request type for the
 * Query/DelegatorValidators RPC method.
 */
export interface QueryDelegatorValidatorsRequest {
	/** delegator_addr defines the delegator address to query for. */
	delegator_addr: string;
	/** pagination defines an optional pagination for the request. */
	pagination: PageRequest | undefined;
}
/**
 * QueryDelegatorValidatorsResponse is response type for the
 * Query/DelegatorValidators RPC method.
 */
export interface QueryDelegatorValidatorsResponse {
	/** validators defines the the validators' info of a delegator. */
	validators: Validator[];
	/** pagination defines the pagination in the response. */
	pagination: PageResponse | undefined;
}
/**
 * QueryDelegatorValidatorRequest is request type for the
 * Query/DelegatorValidator RPC method.
 */
export interface QueryDelegatorValidatorRequest {
	/** delegator_addr defines the delegator address to query for. */
	delegator_addr: string;
	/** validator_addr defines the validator address to query for. */
	validator_addr: string;
}
/**
 * QueryDelegatorValidatorResponse response type for the
 * Query/DelegatorValidator RPC method.
 */
export interface QueryDelegatorValidatorResponse {
	/** validator defines the the validator info. */
	validator: Validator | undefined;
}
/**
 * QueryHistoricalInfoRequest is request type for the Query/HistoricalInfo RPC
 * method.
 */
export interface QueryHistoricalInfoRequest {
	/** height defines at which height to query the historical info. */
	height: number;
}
/**
 * QueryHistoricalInfoResponse is response type for the Query/HistoricalInfo RPC
 * method.
 */
export interface QueryHistoricalInfoResponse {
	/** hist defines the historical info at the given height. */
	hist: HistoricalInfo | undefined;
}
/** QueryPoolRequest is request type for the Query/Pool RPC method. */
export interface QueryPoolRequest {
}
/** QueryPoolResponse is response type for the Query/Pool RPC method. */
export interface QueryPoolResponse {
	/** pool defines the pool info. */
	pool: Pool | undefined;
}
/** QueryParamsRequest is request type for the Query/Params RPC method. */
export interface QueryParamsRequest {
}
/** QueryParamsResponse is response type for the Query/Params RPC method. */
export interface QueryParamsResponse {
	/** params holds all the parameters of this module. */
	params: Params | undefined;
}
declare const QueryValidatorsRequest: {
	encode(message: QueryValidatorsRequest, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): QueryValidatorsRequest;
	fromJSON(object: any): QueryValidatorsRequest;
	toJSON(message: QueryValidatorsRequest): unknown;
	fromPartial(object: DeepPartial<QueryValidatorsRequest>): QueryValidatorsRequest;
};
declare const QueryValidatorsResponse: {
	encode(message: QueryValidatorsResponse, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): QueryValidatorsResponse;
	fromJSON(object: any): QueryValidatorsResponse;
	toJSON(message: QueryValidatorsResponse): unknown;
	fromPartial(object: DeepPartial<QueryValidatorsResponse>): QueryValidatorsResponse;
};
declare const QueryValidatorRequest: {
	encode(message: QueryValidatorRequest, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): QueryValidatorRequest;
	fromJSON(object: any): QueryValidatorRequest;
	toJSON(message: QueryValidatorRequest): unknown;
	fromPartial(object: DeepPartial<QueryValidatorRequest>): QueryValidatorRequest;
};
declare const QueryValidatorResponse: {
	encode(message: QueryValidatorResponse, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): QueryValidatorResponse;
	fromJSON(object: any): QueryValidatorResponse;
	toJSON(message: QueryValidatorResponse): unknown;
	fromPartial(object: DeepPartial<QueryValidatorResponse>): QueryValidatorResponse;
};
declare const QueryValidatorDelegationsRequest: {
	encode(message: QueryValidatorDelegationsRequest, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): QueryValidatorDelegationsRequest;
	fromJSON(object: any): QueryValidatorDelegationsRequest;
	toJSON(message: QueryValidatorDelegationsRequest): unknown;
	fromPartial(object: DeepPartial<QueryValidatorDelegationsRequest>): QueryValidatorDelegationsRequest;
};
declare const QueryValidatorDelegationsResponse: {
	encode(message: QueryValidatorDelegationsResponse, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): QueryValidatorDelegationsResponse;
	fromJSON(object: any): QueryValidatorDelegationsResponse;
	toJSON(message: QueryValidatorDelegationsResponse): unknown;
	fromPartial(object: DeepPartial<QueryValidatorDelegationsResponse>): QueryValidatorDelegationsResponse;
};
declare const QueryValidatorUnbondingDelegationsRequest: {
	encode(message: QueryValidatorUnbondingDelegationsRequest, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): QueryValidatorUnbondingDelegationsRequest;
	fromJSON(object: any): QueryValidatorUnbondingDelegationsRequest;
	toJSON(message: QueryValidatorUnbondingDelegationsRequest): unknown;
	fromPartial(object: DeepPartial<QueryValidatorUnbondingDelegationsRequest>): QueryValidatorUnbondingDelegationsRequest;
};
declare const QueryValidatorUnbondingDelegationsResponse: {
	encode(message: QueryValidatorUnbondingDelegationsResponse, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): QueryValidatorUnbondingDelegationsResponse;
	fromJSON(object: any): QueryValidatorUnbondingDelegationsResponse;
	toJSON(message: QueryValidatorUnbondingDelegationsResponse): unknown;
	fromPartial(object: DeepPartial<QueryValidatorUnbondingDelegationsResponse>): QueryValidatorUnbondingDelegationsResponse;
};
declare const QueryDelegationRequest: {
	encode(message: QueryDelegationRequest, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): QueryDelegationRequest;
	fromJSON(object: any): QueryDelegationRequest;
	toJSON(message: QueryDelegationRequest): unknown;
	fromPartial(object: DeepPartial<QueryDelegationRequest>): QueryDelegationRequest;
};
declare const QueryDelegationResponse: {
	encode(message: QueryDelegationResponse, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): QueryDelegationResponse;
	fromJSON(object: any): QueryDelegationResponse;
	toJSON(message: QueryDelegationResponse): unknown;
	fromPartial(object: DeepPartial<QueryDelegationResponse>): QueryDelegationResponse;
};
declare const QueryUnbondingDelegationRequest: {
	encode(message: QueryUnbondingDelegationRequest, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): QueryUnbondingDelegationRequest;
	fromJSON(object: any): QueryUnbondingDelegationRequest;
	toJSON(message: QueryUnbondingDelegationRequest): unknown;
	fromPartial(object: DeepPartial<QueryUnbondingDelegationRequest>): QueryUnbondingDelegationRequest;
};
declare const QueryUnbondingDelegationResponse: {
	encode(message: QueryUnbondingDelegationResponse, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): QueryUnbondingDelegationResponse;
	fromJSON(object: any): QueryUnbondingDelegationResponse;
	toJSON(message: QueryUnbondingDelegationResponse): unknown;
	fromPartial(object: DeepPartial<QueryUnbondingDelegationResponse>): QueryUnbondingDelegationResponse;
};
declare const QueryDelegatorDelegationsRequest: {
	encode(message: QueryDelegatorDelegationsRequest, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): QueryDelegatorDelegationsRequest;
	fromJSON(object: any): QueryDelegatorDelegationsRequest;
	toJSON(message: QueryDelegatorDelegationsRequest): unknown;
	fromPartial(object: DeepPartial<QueryDelegatorDelegationsRequest>): QueryDelegatorDelegationsRequest;
};
declare const QueryDelegatorDelegationsResponse: {
	encode(message: QueryDelegatorDelegationsResponse, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): QueryDelegatorDelegationsResponse;
	fromJSON(object: any): QueryDelegatorDelegationsResponse;
	toJSON(message: QueryDelegatorDelegationsResponse): unknown;
	fromPartial(object: DeepPartial<QueryDelegatorDelegationsResponse>): QueryDelegatorDelegationsResponse;
};
declare const QueryDelegatorUnbondingDelegationsRequest: {
	encode(message: QueryDelegatorUnbondingDelegationsRequest, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): QueryDelegatorUnbondingDelegationsRequest;
	fromJSON(object: any): QueryDelegatorUnbondingDelegationsRequest;
	toJSON(message: QueryDelegatorUnbondingDelegationsRequest): unknown;
	fromPartial(object: DeepPartial<QueryDelegatorUnbondingDelegationsRequest>): QueryDelegatorUnbondingDelegationsRequest;
};
declare const QueryDelegatorUnbondingDelegationsResponse: {
	encode(message: QueryDelegatorUnbondingDelegationsResponse, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): QueryDelegatorUnbondingDelegationsResponse;
	fromJSON(object: any): QueryDelegatorUnbondingDelegationsResponse;
	toJSON(message: QueryDelegatorUnbondingDelegationsResponse): unknown;
	fromPartial(object: DeepPartial<QueryDelegatorUnbondingDelegationsResponse>): QueryDelegatorUnbondingDelegationsResponse;
};
declare const QueryRedelegationsRequest: {
	encode(message: QueryRedelegationsRequest, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): QueryRedelegationsRequest;
	fromJSON(object: any): QueryRedelegationsRequest;
	toJSON(message: QueryRedelegationsRequest): unknown;
	fromPartial(object: DeepPartial<QueryRedelegationsRequest>): QueryRedelegationsRequest;
};
declare const QueryRedelegationsResponse: {
	encode(message: QueryRedelegationsResponse, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): QueryRedelegationsResponse;
	fromJSON(object: any): QueryRedelegationsResponse;
	toJSON(message: QueryRedelegationsResponse): unknown;
	fromPartial(object: DeepPartial<QueryRedelegationsResponse>): QueryRedelegationsResponse;
};
declare const QueryDelegatorValidatorsRequest: {
	encode(message: QueryDelegatorValidatorsRequest, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): QueryDelegatorValidatorsRequest;
	fromJSON(object: any): QueryDelegatorValidatorsRequest;
	toJSON(message: QueryDelegatorValidatorsRequest): unknown;
	fromPartial(object: DeepPartial<QueryDelegatorValidatorsRequest>): QueryDelegatorValidatorsRequest;
};
declare const QueryDelegatorValidatorsResponse: {
	encode(message: QueryDelegatorValidatorsResponse, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): QueryDelegatorValidatorsResponse;
	fromJSON(object: any): QueryDelegatorValidatorsResponse;
	toJSON(message: QueryDelegatorValidatorsResponse): unknown;
	fromPartial(object: DeepPartial<QueryDelegatorValidatorsResponse>): QueryDelegatorValidatorsResponse;
};
declare const QueryDelegatorValidatorRequest: {
	encode(message: QueryDelegatorValidatorRequest, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): QueryDelegatorValidatorRequest;
	fromJSON(object: any): QueryDelegatorValidatorRequest;
	toJSON(message: QueryDelegatorValidatorRequest): unknown;
	fromPartial(object: DeepPartial<QueryDelegatorValidatorRequest>): QueryDelegatorValidatorRequest;
};
declare const QueryDelegatorValidatorResponse: {
	encode(message: QueryDelegatorValidatorResponse, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): QueryDelegatorValidatorResponse;
	fromJSON(object: any): QueryDelegatorValidatorResponse;
	toJSON(message: QueryDelegatorValidatorResponse): unknown;
	fromPartial(object: DeepPartial<QueryDelegatorValidatorResponse>): QueryDelegatorValidatorResponse;
};
declare const QueryHistoricalInfoRequest: {
	encode(message: QueryHistoricalInfoRequest, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): QueryHistoricalInfoRequest;
	fromJSON(object: any): QueryHistoricalInfoRequest;
	toJSON(message: QueryHistoricalInfoRequest): unknown;
	fromPartial(object: DeepPartial<QueryHistoricalInfoRequest>): QueryHistoricalInfoRequest;
};
declare const QueryHistoricalInfoResponse: {
	encode(message: QueryHistoricalInfoResponse, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): QueryHistoricalInfoResponse;
	fromJSON(object: any): QueryHistoricalInfoResponse;
	toJSON(message: QueryHistoricalInfoResponse): unknown;
	fromPartial(object: DeepPartial<QueryHistoricalInfoResponse>): QueryHistoricalInfoResponse;
};
declare const QueryPoolRequest: {
	encode(_: QueryPoolRequest, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): QueryPoolRequest;
	fromJSON(_: any): QueryPoolRequest;
	toJSON(_: QueryPoolRequest): unknown;
	fromPartial(_: DeepPartial<QueryPoolRequest>): QueryPoolRequest;
};
declare const QueryPoolResponse: {
	encode(message: QueryPoolResponse, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): QueryPoolResponse;
	fromJSON(object: any): QueryPoolResponse;
	toJSON(message: QueryPoolResponse): unknown;
	fromPartial(object: DeepPartial<QueryPoolResponse>): QueryPoolResponse;
};
declare const QueryParamsRequest: {
	encode(_: QueryParamsRequest, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): QueryParamsRequest;
	fromJSON(_: any): QueryParamsRequest;
	toJSON(_: QueryParamsRequest): unknown;
	fromPartial(_: DeepPartial<QueryParamsRequest>): QueryParamsRequest;
};
declare const QueryParamsResponse: {
	encode(message: QueryParamsResponse, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): QueryParamsResponse;
	fromJSON(object: any): QueryParamsResponse;
	toJSON(message: QueryParamsResponse): unknown;
	fromPartial(object: DeepPartial<QueryParamsResponse>): QueryParamsResponse;
};
/** Query defines the gRPC querier service. */
export interface Query {
	/** Validators queries all validators that match the given status. */
	Validators(request: QueryValidatorsRequest): Promise<QueryValidatorsResponse>;
	/** Validator queries validator info for given validator address. */
	Validator(request: QueryValidatorRequest): Promise<QueryValidatorResponse>;
	/** ValidatorDelegations queries delegate info for given validator. */
	ValidatorDelegations(request: QueryValidatorDelegationsRequest): Promise<QueryValidatorDelegationsResponse>;
	/** ValidatorUnbondingDelegations queries unbonding delegations of a validator. */
	ValidatorUnbondingDelegations(request: QueryValidatorUnbondingDelegationsRequest): Promise<QueryValidatorUnbondingDelegationsResponse>;
	/** Delegation queries delegate info for given validator delegator pair. */
	Delegation(request: QueryDelegationRequest): Promise<QueryDelegationResponse>;
	/**
	 * UnbondingDelegation queries unbonding info for given validator delegator
	 * pair.
	 */
	UnbondingDelegation(request: QueryUnbondingDelegationRequest): Promise<QueryUnbondingDelegationResponse>;
	/** DelegatorDelegations queries all delegations of a given delegator address. */
	DelegatorDelegations(request: QueryDelegatorDelegationsRequest): Promise<QueryDelegatorDelegationsResponse>;
	/**
	 * DelegatorUnbondingDelegations queries all unbonding delegations of a given
	 * delegator address.
	 */
	DelegatorUnbondingDelegations(request: QueryDelegatorUnbondingDelegationsRequest): Promise<QueryDelegatorUnbondingDelegationsResponse>;
	/** Redelegations queries redelegations of given address. */
	Redelegations(request: QueryRedelegationsRequest): Promise<QueryRedelegationsResponse>;
	/**
	 * DelegatorValidators queries all validators info for given delegator
	 * address.
	 */
	DelegatorValidators(request: QueryDelegatorValidatorsRequest): Promise<QueryDelegatorValidatorsResponse>;
	/**
	 * DelegatorValidator queries validator info for given delegator validator
	 * pair.
	 */
	DelegatorValidator(request: QueryDelegatorValidatorRequest): Promise<QueryDelegatorValidatorResponse>;
	/** HistoricalInfo queries the historical info for given height. */
	HistoricalInfo(request: QueryHistoricalInfoRequest): Promise<QueryHistoricalInfoResponse>;
	/** Pool queries the pool info. */
	Pool(request: QueryPoolRequest): Promise<QueryPoolResponse>;
	/** Parameters queries the staking parameters. */
	Params(request: QueryParamsRequest): Promise<QueryParamsResponse>;
}
declare class QueryClientImpl implements Query {
	private readonly rpc;
	constructor(rpc: Rpc);
	Validators(request: QueryValidatorsRequest): Promise<QueryValidatorsResponse>;
	Validator(request: QueryValidatorRequest): Promise<QueryValidatorResponse>;
	ValidatorDelegations(request: QueryValidatorDelegationsRequest): Promise<QueryValidatorDelegationsResponse>;
	ValidatorUnbondingDelegations(request: QueryValidatorUnbondingDelegationsRequest): Promise<QueryValidatorUnbondingDelegationsResponse>;
	Delegation(request: QueryDelegationRequest): Promise<QueryDelegationResponse>;
	UnbondingDelegation(request: QueryUnbondingDelegationRequest): Promise<QueryUnbondingDelegationResponse>;
	DelegatorDelegations(request: QueryDelegatorDelegationsRequest): Promise<QueryDelegatorDelegationsResponse>;
	DelegatorUnbondingDelegations(request: QueryDelegatorUnbondingDelegationsRequest): Promise<QueryDelegatorUnbondingDelegationsResponse>;
	Redelegations(request: QueryRedelegationsRequest): Promise<QueryRedelegationsResponse>;
	DelegatorValidators(request: QueryDelegatorValidatorsRequest): Promise<QueryDelegatorValidatorsResponse>;
	DelegatorValidator(request: QueryDelegatorValidatorRequest): Promise<QueryDelegatorValidatorResponse>;
	HistoricalInfo(request: QueryHistoricalInfoRequest): Promise<QueryHistoricalInfoResponse>;
	Pool(request: QueryPoolRequest): Promise<QueryPoolResponse>;
	Params(request: QueryParamsRequest): Promise<QueryParamsResponse>;
}
export interface Rpc {
	request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}
export declare type Builtin = Date | Function | Uint8Array | string | number | undefined;
export declare type DeepPartial<T> = T extends Builtin ? T : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {} ? {
	[K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
/**
 * DecCoin defines a token with a denomination and a decimal amount.
 *
 * NOTE: The amount field is an Dec which implements the custom method
 * signatures required by gogoproto.
 */
export interface DecCoin {
	denom: string;
	amount: string;
}
declare const DecCoin: {
	encode(message: DecCoin, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): DecCoin;
	fromJSON(object: any): DecCoin;
	toJSON(message: DecCoin): unknown;
	fromPartial(object: DeepPartial<DecCoin>): DecCoin;
};
export declare type Builtin = Date | Function | Uint8Array | string | number | undefined;
export declare type DeepPartial<T> = T extends Builtin ? T : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {} ? {
	[K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
/** Params defines the set of params for the distribution module. */
export interface Params {
	community_tax: string;
	base_proposer_reward: string;
	bonus_proposer_reward: string;
	withdraw_addr_enabled: boolean;
}
/**
 * ValidatorAccumulatedCommission represents accumulated commission
 * for a validator kept as a running counter, can be withdrawn at any time.
 */
export interface ValidatorAccumulatedCommission {
	commission: DecCoin[];
}
/**
 * ValidatorOutstandingRewards represents outstanding (un-withdrawn) rewards
 * for a validator inexpensive to track, allows simple sanity checks.
 */
export interface ValidatorOutstandingRewards {
	rewards: DecCoin[];
}
/**
 * ValidatorSlashEvent represents a validator slash event.
 * Height is implicit within the store key.
 * This is needed to calculate appropriate amount of staking tokens
 * for delegations which are withdrawn after a slash has occurred.
 */
export interface ValidatorSlashEvent {
	validator_period: number;
	fraction: string;
}
/**
 * DelegationDelegatorReward represents the properties
 * of a delegator's delegation reward.
 */
export interface DelegationDelegatorReward {
	validator_address: string;
	reward: DecCoin[];
}
declare const Params: {
	encode(message: Params, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): Params;
	fromJSON(object: any): Params;
	toJSON(message: Params): unknown;
	fromPartial(object: DeepPartial<Params>): Params;
};
declare const ValidatorAccumulatedCommission: {
	encode(message: ValidatorAccumulatedCommission, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): ValidatorAccumulatedCommission;
	fromJSON(object: any): ValidatorAccumulatedCommission;
	toJSON(message: ValidatorAccumulatedCommission): unknown;
	fromPartial(object: DeepPartial<ValidatorAccumulatedCommission>): ValidatorAccumulatedCommission;
};
declare const ValidatorOutstandingRewards: {
	encode(message: ValidatorOutstandingRewards, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): ValidatorOutstandingRewards;
	fromJSON(object: any): ValidatorOutstandingRewards;
	toJSON(message: ValidatorOutstandingRewards): unknown;
	fromPartial(object: DeepPartial<ValidatorOutstandingRewards>): ValidatorOutstandingRewards;
};
declare const ValidatorSlashEvent: {
	encode(message: ValidatorSlashEvent, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): ValidatorSlashEvent;
	fromJSON(object: any): ValidatorSlashEvent;
	toJSON(message: ValidatorSlashEvent): unknown;
	fromPartial(object: DeepPartial<ValidatorSlashEvent>): ValidatorSlashEvent;
};
declare const DelegationDelegatorReward: {
	encode(message: DelegationDelegatorReward, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): DelegationDelegatorReward;
	fromJSON(object: any): DelegationDelegatorReward;
	toJSON(message: DelegationDelegatorReward): unknown;
	fromPartial(object: DeepPartial<DelegationDelegatorReward>): DelegationDelegatorReward;
};
export declare type Builtin = Date | Function | Uint8Array | string | number | undefined;
export declare type DeepPartial<T> = T extends Builtin ? T : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {} ? {
	[K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
/**
 * PageRequest is to be embedded in gRPC request messages for efficient
 * pagination. Ex:
 *
 *  message SomeRequest {
 *          Foo some_parameter = 1;
 *          PageRequest pagination = 2;
 *  }
 */
export interface PageRequest {
	/**
	 * key is a value returned in PageResponse.next_key to begin
	 * querying the next page most efficiently. Only one of offset or key
	 * should be set.
	 */
	key: Uint8Array;
	/**
	 * offset is a numeric offset that can be used when key is unavailable.
	 * It is less efficient than using key. Only one of offset or key should
	 * be set.
	 */
	offset: number;
	/**
	 * limit is the total number of results to be returned in the result page.
	 * If left empty it will default to a value to be set by each app.
	 */
	limit: number;
	/**
	 * count_total is set to true  to indicate that the result set should include
	 * a count of the total number of items available for pagination in UIs.
	 * count_total is only respected when offset is used. It is ignored when key
	 * is set.
	 */
	count_total: boolean;
	/** reverse is set to true if results are to be returned in the descending order. */
	reverse: boolean;
}
/**
 * PageResponse is to be embedded in gRPC response messages where the
 * corresponding request message has used PageRequest.
 *
 *  message SomeResponse {
 *          repeated Bar results = 1;
 *          PageResponse page = 2;
 *  }
 */
export interface PageResponse {
	/**
	 * next_key is the key to be passed to PageRequest.key to
	 * query the next page most efficiently
	 */
	next_key: Uint8Array;
	/**
	 * total is total number of results available if PageRequest.count_total
	 * was set, its value is undefined otherwise
	 */
	total: number;
}
declare const PageRequest: {
	encode(message: PageRequest, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): PageRequest;
	fromJSON(object: any): PageRequest;
	toJSON(message: PageRequest): unknown;
	fromPartial(object: DeepPartial<PageRequest>): PageRequest;
};
declare const PageResponse: {
	encode(message: PageResponse, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): PageResponse;
	fromJSON(object: any): PageResponse;
	toJSON(message: PageResponse): unknown;
	fromPartial(object: DeepPartial<PageResponse>): PageResponse;
};
export declare type Builtin = Date | Function | Uint8Array | string | number | undefined;
export declare type DeepPartial<T> = T extends Builtin ? T : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {} ? {
	[K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
/** QueryParamsRequest is the request type for the Query/Params RPC method. */
export interface QueryParamsRequest {
}
/** QueryParamsResponse is the response type for the Query/Params RPC method. */
export interface QueryParamsResponse {
	/** params defines the parameters of the module. */
	params: Params | undefined;
}
/**
 * QueryValidatorOutstandingRewardsRequest is the request type for the
 * Query/ValidatorOutstandingRewards RPC method.
 */
export interface QueryValidatorOutstandingRewardsRequest {
	/** validator_address defines the validator address to query for. */
	validator_address: string;
}
/**
 * QueryValidatorOutstandingRewardsResponse is the response type for the
 * Query/ValidatorOutstandingRewards RPC method.
 */
export interface QueryValidatorOutstandingRewardsResponse {
	rewards: ValidatorOutstandingRewards | undefined;
}
/**
 * QueryValidatorCommissionRequest is the request type for the
 * Query/ValidatorCommission RPC method
 */
export interface QueryValidatorCommissionRequest {
	/** validator_address defines the validator address to query for. */
	validator_address: string;
}
/**
 * QueryValidatorCommissionResponse is the response type for the
 * Query/ValidatorCommission RPC method
 */
export interface QueryValidatorCommissionResponse {
	/** commission defines the commision the validator received. */
	commission: ValidatorAccumulatedCommission | undefined;
}
/**
 * QueryValidatorSlashesRequest is the request type for the
 * Query/ValidatorSlashes RPC method
 */
export interface QueryValidatorSlashesRequest {
	/** validator_address defines the validator address to query for. */
	validator_address: string;
	/** starting_height defines the optional starting height to query the slashes. */
	starting_height: number;
	/** starting_height defines the optional ending height to query the slashes. */
	ending_height: number;
	/** pagination defines an optional pagination for the request. */
	pagination: PageRequest | undefined;
}
/**
 * QueryValidatorSlashesResponse is the response type for the
 * Query/ValidatorSlashes RPC method.
 */
export interface QueryValidatorSlashesResponse {
	/** slashes defines the slashes the validator received. */
	slashes: ValidatorSlashEvent[];
	/** pagination defines the pagination in the response. */
	pagination: PageResponse | undefined;
}
/**
 * QueryDelegationRewardsRequest is the request type for the
 * Query/DelegationRewards RPC method.
 */
export interface QueryDelegationRewardsRequest {
	/** delegator_address defines the delegator address to query for. */
	delegator_address: string;
	/** validator_address defines the validator address to query for. */
	validator_address: string;
}
/**
 * QueryDelegationRewardsResponse is the response type for the
 * Query/DelegationRewards RPC method.
 */
export interface QueryDelegationRewardsResponse {
	/** rewards defines the rewards accrued by a delegation. */
	rewards: DecCoin[];
}
/**
 * QueryDelegationTotalRewardsRequest is the request type for the
 * Query/DelegationTotalRewards RPC method.
 */
export interface QueryDelegationTotalRewardsRequest {
	/** delegator_address defines the delegator address to query for. */
	delegator_address: string;
}
/**
 * QueryDelegationTotalRewardsResponse is the response type for the
 * Query/DelegationTotalRewards RPC method.
 */
export interface QueryDelegationTotalRewardsResponse {
	/** rewards defines all the rewards accrued by a delegator. */
	rewards: DelegationDelegatorReward[];
	/** total defines the sum of all the rewards. */
	total: DecCoin[];
}
/**
 * QueryDelegatorValidatorsRequest is the request type for the
 * Query/DelegatorValidators RPC method.
 */
export interface QueryDelegatorValidatorsRequest {
	/** delegator_address defines the delegator address to query for. */
	delegator_address: string;
}
/**
 * QueryDelegatorValidatorsResponse is the response type for the
 * Query/DelegatorValidators RPC method.
 */
export interface QueryDelegatorValidatorsResponse {
	/** validators defines the validators a delegator is delegating for. */
	validators: string[];
}
/**
 * QueryDelegatorWithdrawAddressRequest is the request type for the
 * Query/DelegatorWithdrawAddress RPC method.
 */
export interface QueryDelegatorWithdrawAddressRequest {
	/** delegator_address defines the delegator address to query for. */
	delegator_address: string;
}
/**
 * QueryDelegatorWithdrawAddressResponse is the response type for the
 * Query/DelegatorWithdrawAddress RPC method.
 */
export interface QueryDelegatorWithdrawAddressResponse {
	/** withdraw_address defines the delegator address to query for. */
	withdraw_address: string;
}
/**
 * QueryCommunityPoolRequest is the request type for the Query/CommunityPool RPC
 * method.
 */
export interface QueryCommunityPoolRequest {
}
/**
 * QueryCommunityPoolResponse is the response type for the Query/CommunityPool
 * RPC method.
 */
export interface QueryCommunityPoolResponse {
	/** pool defines community pool's coins. */
	pool: DecCoin[];
}
declare const QueryParamsRequest: {
	encode(_: QueryParamsRequest, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): QueryParamsRequest;
	fromJSON(_: any): QueryParamsRequest;
	toJSON(_: QueryParamsRequest): unknown;
	fromPartial(_: DeepPartial<QueryParamsRequest>): QueryParamsRequest;
};
declare const QueryParamsResponse: {
	encode(message: QueryParamsResponse, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): QueryParamsResponse;
	fromJSON(object: any): QueryParamsResponse;
	toJSON(message: QueryParamsResponse): unknown;
	fromPartial(object: DeepPartial<QueryParamsResponse>): QueryParamsResponse;
};
declare const QueryValidatorOutstandingRewardsRequest: {
	encode(message: QueryValidatorOutstandingRewardsRequest, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): QueryValidatorOutstandingRewardsRequest;
	fromJSON(object: any): QueryValidatorOutstandingRewardsRequest;
	toJSON(message: QueryValidatorOutstandingRewardsRequest): unknown;
	fromPartial(object: DeepPartial<QueryValidatorOutstandingRewardsRequest>): QueryValidatorOutstandingRewardsRequest;
};
declare const QueryValidatorOutstandingRewardsResponse: {
	encode(message: QueryValidatorOutstandingRewardsResponse, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): QueryValidatorOutstandingRewardsResponse;
	fromJSON(object: any): QueryValidatorOutstandingRewardsResponse;
	toJSON(message: QueryValidatorOutstandingRewardsResponse): unknown;
	fromPartial(object: DeepPartial<QueryValidatorOutstandingRewardsResponse>): QueryValidatorOutstandingRewardsResponse;
};
declare const QueryValidatorCommissionRequest: {
	encode(message: QueryValidatorCommissionRequest, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): QueryValidatorCommissionRequest;
	fromJSON(object: any): QueryValidatorCommissionRequest;
	toJSON(message: QueryValidatorCommissionRequest): unknown;
	fromPartial(object: DeepPartial<QueryValidatorCommissionRequest>): QueryValidatorCommissionRequest;
};
declare const QueryValidatorCommissionResponse: {
	encode(message: QueryValidatorCommissionResponse, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): QueryValidatorCommissionResponse;
	fromJSON(object: any): QueryValidatorCommissionResponse;
	toJSON(message: QueryValidatorCommissionResponse): unknown;
	fromPartial(object: DeepPartial<QueryValidatorCommissionResponse>): QueryValidatorCommissionResponse;
};
declare const QueryValidatorSlashesRequest: {
	encode(message: QueryValidatorSlashesRequest, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): QueryValidatorSlashesRequest;
	fromJSON(object: any): QueryValidatorSlashesRequest;
	toJSON(message: QueryValidatorSlashesRequest): unknown;
	fromPartial(object: DeepPartial<QueryValidatorSlashesRequest>): QueryValidatorSlashesRequest;
};
declare const QueryValidatorSlashesResponse: {
	encode(message: QueryValidatorSlashesResponse, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): QueryValidatorSlashesResponse;
	fromJSON(object: any): QueryValidatorSlashesResponse;
	toJSON(message: QueryValidatorSlashesResponse): unknown;
	fromPartial(object: DeepPartial<QueryValidatorSlashesResponse>): QueryValidatorSlashesResponse;
};
declare const QueryDelegationRewardsRequest: {
	encode(message: QueryDelegationRewardsRequest, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): QueryDelegationRewardsRequest;
	fromJSON(object: any): QueryDelegationRewardsRequest;
	toJSON(message: QueryDelegationRewardsRequest): unknown;
	fromPartial(object: DeepPartial<QueryDelegationRewardsRequest>): QueryDelegationRewardsRequest;
};
declare const QueryDelegationRewardsResponse: {
	encode(message: QueryDelegationRewardsResponse, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): QueryDelegationRewardsResponse;
	fromJSON(object: any): QueryDelegationRewardsResponse;
	toJSON(message: QueryDelegationRewardsResponse): unknown;
	fromPartial(object: DeepPartial<QueryDelegationRewardsResponse>): QueryDelegationRewardsResponse;
};
declare const QueryDelegationTotalRewardsRequest: {
	encode(message: QueryDelegationTotalRewardsRequest, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): QueryDelegationTotalRewardsRequest;
	fromJSON(object: any): QueryDelegationTotalRewardsRequest;
	toJSON(message: QueryDelegationTotalRewardsRequest): unknown;
	fromPartial(object: DeepPartial<QueryDelegationTotalRewardsRequest>): QueryDelegationTotalRewardsRequest;
};
declare const QueryDelegationTotalRewardsResponse: {
	encode(message: QueryDelegationTotalRewardsResponse, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): QueryDelegationTotalRewardsResponse;
	fromJSON(object: any): QueryDelegationTotalRewardsResponse;
	toJSON(message: QueryDelegationTotalRewardsResponse): unknown;
	fromPartial(object: DeepPartial<QueryDelegationTotalRewardsResponse>): QueryDelegationTotalRewardsResponse;
};
declare const QueryDelegatorValidatorsRequest: {
	encode(message: QueryDelegatorValidatorsRequest, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): QueryDelegatorValidatorsRequest;
	fromJSON(object: any): QueryDelegatorValidatorsRequest;
	toJSON(message: QueryDelegatorValidatorsRequest): unknown;
	fromPartial(object: DeepPartial<QueryDelegatorValidatorsRequest>): QueryDelegatorValidatorsRequest;
};
declare const QueryDelegatorValidatorsResponse: {
	encode(message: QueryDelegatorValidatorsResponse, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): QueryDelegatorValidatorsResponse;
	fromJSON(object: any): QueryDelegatorValidatorsResponse;
	toJSON(message: QueryDelegatorValidatorsResponse): unknown;
	fromPartial(object: DeepPartial<QueryDelegatorValidatorsResponse>): QueryDelegatorValidatorsResponse;
};
declare const QueryDelegatorWithdrawAddressRequest: {
	encode(message: QueryDelegatorWithdrawAddressRequest, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): QueryDelegatorWithdrawAddressRequest;
	fromJSON(object: any): QueryDelegatorWithdrawAddressRequest;
	toJSON(message: QueryDelegatorWithdrawAddressRequest): unknown;
	fromPartial(object: DeepPartial<QueryDelegatorWithdrawAddressRequest>): QueryDelegatorWithdrawAddressRequest;
};
declare const QueryDelegatorWithdrawAddressResponse: {
	encode(message: QueryDelegatorWithdrawAddressResponse, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): QueryDelegatorWithdrawAddressResponse;
	fromJSON(object: any): QueryDelegatorWithdrawAddressResponse;
	toJSON(message: QueryDelegatorWithdrawAddressResponse): unknown;
	fromPartial(object: DeepPartial<QueryDelegatorWithdrawAddressResponse>): QueryDelegatorWithdrawAddressResponse;
};
declare const QueryCommunityPoolRequest: {
	encode(_: QueryCommunityPoolRequest, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): QueryCommunityPoolRequest;
	fromJSON(_: any): QueryCommunityPoolRequest;
	toJSON(_: QueryCommunityPoolRequest): unknown;
	fromPartial(_: DeepPartial<QueryCommunityPoolRequest>): QueryCommunityPoolRequest;
};
declare const QueryCommunityPoolResponse: {
	encode(message: QueryCommunityPoolResponse, writer?: Writer): Writer;
	decode(input: Reader | Uint8Array, length?: number): QueryCommunityPoolResponse;
	fromJSON(object: any): QueryCommunityPoolResponse;
	toJSON(message: QueryCommunityPoolResponse): unknown;
	fromPartial(object: DeepPartial<QueryCommunityPoolResponse>): QueryCommunityPoolResponse;
};
/** Query defines the gRPC querier service for distribution module. */
export interface Query {
	/** Params queries params of the distribution module. */
	Params(request: QueryParamsRequest): Promise<QueryParamsResponse>;
	/** ValidatorOutstandingRewards queries rewards of a validator address. */
	ValidatorOutstandingRewards(request: QueryValidatorOutstandingRewardsRequest): Promise<QueryValidatorOutstandingRewardsResponse>;
	/** ValidatorCommission queries accumulated commission for a validator. */
	ValidatorCommission(request: QueryValidatorCommissionRequest): Promise<QueryValidatorCommissionResponse>;
	/** ValidatorSlashes queries slash events of a validator. */
	ValidatorSlashes(request: QueryValidatorSlashesRequest): Promise<QueryValidatorSlashesResponse>;
	/** DelegationRewards queries the total rewards accrued by a delegation. */
	DelegationRewards(request: QueryDelegationRewardsRequest): Promise<QueryDelegationRewardsResponse>;
	/**
	 * DelegationTotalRewards queries the total rewards accrued by a each
	 * validator.
	 */
	DelegationTotalRewards(request: QueryDelegationTotalRewardsRequest): Promise<QueryDelegationTotalRewardsResponse>;
	/** DelegatorValidators queries the validators of a delegator. */
	DelegatorValidators(request: QueryDelegatorValidatorsRequest): Promise<QueryDelegatorValidatorsResponse>;
	/** DelegatorWithdrawAddress queries withdraw address of a delegator. */
	DelegatorWithdrawAddress(request: QueryDelegatorWithdrawAddressRequest): Promise<QueryDelegatorWithdrawAddressResponse>;
	/** CommunityPool queries the community pool coins. */
	CommunityPool(request: QueryCommunityPoolRequest): Promise<QueryCommunityPoolResponse>;
}
declare class QueryClientImpl implements Query {
	private readonly rpc;
	constructor(rpc: Rpc);
	Params(request: QueryParamsRequest): Promise<QueryParamsResponse>;
	ValidatorOutstandingRewards(request: QueryValidatorOutstandingRewardsRequest): Promise<QueryValidatorOutstandingRewardsResponse>;
	ValidatorCommission(request: QueryValidatorCommissionRequest): Promise<QueryValidatorCommissionResponse>;
	ValidatorSlashes(request: QueryValidatorSlashesRequest): Promise<QueryValidatorSlashesResponse>;
	DelegationRewards(request: QueryDelegationRewardsRequest): Promise<QueryDelegationRewardsResponse>;
	DelegationTotalRewards(request: QueryDelegationTotalRewardsRequest): Promise<QueryDelegationTotalRewardsResponse>;
	DelegatorValidators(request: QueryDelegatorValidatorsRequest): Promise<QueryDelegatorValidatorsResponse>;
	DelegatorWithdrawAddress(request: QueryDelegatorWithdrawAddressRequest): Promise<QueryDelegatorWithdrawAddressResponse>;
	CommunityPool(request: QueryCommunityPoolRequest): Promise<QueryCommunityPoolResponse>;
}
export interface Rpc {
	request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}
export declare type Builtin = Date | Function | Uint8Array | string | number | undefined;
export declare type DeepPartial<T> = T extends Builtin ? T : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {} ? {
	[K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
export declare type QueryClientImpl = {
	storage: StorageQueryClientImpl;
	bank: BankQueryClientImpl;
	faucet: FaucetQueryClientImpl;
	tax: TaxQueryClientImpl;
	staking: StakingQueryClientImpl;
	distribution: DistributionQueryClientImpl;
};
export interface BluzelleClient {
	url: string;
	address: string;
	sgClient: SigningStargateClient;
	queryClient: QueryClientImpl;
	tmClient: Tendermint34Client;
}
export declare const newBluzelleClient: (config: {
	wallet: () => Promise<BluzelleWallet>;
	url: string;
}) => Promise<BluzelleClient>;
declare class SigningBluzelleClient extends SigningStargateClient {
	private wallet;
	protected constructor(tmClient: Tendermint34Client | undefined, signer: BluzelleWallet, options: SigningStargateClientOptions);
	getSequenceFromNetwork(address: string): Promise<SequenceResponse>;
	getSequence(address: string): Promise<SequenceResponse>;
	static connectWithSigner(endpoint: string, signer: BluzelleWallet, options?: {}): Promise<SigningBluzelleClient>;
}
export interface BluzelleWallet extends OfflineDirectSigner {
	getSequence: (client: SigningBluzelleClient, signerAddress: string) => Promise<SequenceResponse>;
}
export interface LocalWalletOptions {
	coinType?: number;
	index?: number;
}
export declare const newLocalWallet: (mnemonic: string, options?: LocalWalletOptions) => () => Promise<BluzelleWallet>;
export declare type AccountAddress = string;
export declare class BluzelleLocalWallet extends DirectSecp256k1HdWallet implements BluzelleWallet {
	sequenceTable: Record<AccountAddress, SequenceResponse>;
	getSequenceQueue: Promise<SequenceResponse>;
	static fromMnemonic(mnemonic: string, options?: Partial<DirectSecp256k1HdWalletOptions>): Promise<BluzelleLocalWallet>;
	getSequence(client: SigningBluzelleClient, signerAddress: string): Promise<SequenceResponse>;
}
export interface SignDoc {
	bodyBytes: Uint8Array;
	authInfoBytes: Uint8Array;
	chainId: string;
	accountNumber: Long;
}
export declare const newKeplrWallet: (nodeAddress: string) => () => Promise<BluzelleWallet>;
export declare type AccountAddress = string;
export declare class BluzelleKeplrWallet implements BluzelleWallet {
	getAccounts: () => Promise<readonly AccountData[]>;
	signDirect: (signerAddress: string, signDoc: SignDoc) => Promise<DirectSignResponse>;
	constructor(keplrOfflineSigner: OfflineDirectSigner);
	sequenceTable: Record<AccountAddress, SequenceResponse>;
	getSequenceQueue: Promise<SequenceResponse>;
	getSequence(client: SigningBluzelleClient, signerAddress: string): Promise<SequenceResponse>;
}
export declare function createAddress(): Promise<{
	mnemonic: string;
	address: string;
}>;
export declare function mint(client: BluzelleClient, address?: string): Promise<{
	mnemonic: string;
	address: string;
}>;
export declare type BluzelleDelegatorDelegationsResponse = {
	pagination: PageResponse;
	delegations: BluzelleDelegationResponse[];
};
export declare type BluzelleDelegationResponse = {
	delegation: BluzelleDelegation;
	balance: BluzelleCoin;
};
export declare type BluzelleDelegation = {
	validatorAddress: string;
	delegatorAddress: string;
	shares: number;
};
export declare type BluzelleCoin = {
	denom: string;
	amount: number;
};
export declare const hasContent: (client: BluzelleClient, cid: string) => Promise<boolean>;
export declare const getAccountBalance: (client: BluzelleClient, address: string) => Promise<number>;
export declare const getTaxInfo: (client: BluzelleClient) => Promise<QueryGetTaxInfoResponse>;
export declare const getDelegations: (client: BluzelleClient, delegatorAddress: string, options?: PageRequest) => Promise<BluzelleDelegatorDelegationsResponse>;
export declare const getDelegation: (client: BluzelleClient, delegatorAddress: string, validatorAddress: string) => Promise<BluzelleDelegationResponse>;
export declare const getValidatorsInfo: (client: BluzelleClient, status?: "BOND_STATUS_UNBONDED" | "BOND_STATUS_UNBONDING" | "BOND_STATUS_BONDED", options?: PageRequest) => Promise<QueryValidatorsResponse>;
export declare const getDelegationRewards: (client: BluzelleClient, delegatorAddress: string, validatorAddress: string) => Promise<BluzelleCoin[]>;
export interface NodeStatusResponse {
	nodeId: string;
	chainId: string;
	moniker: string;
	blockHeight: number;
	caughtUp: boolean;
}
export interface ValidatorResponse {
	address: string;
	votingPower: number;
}
export declare const getStatus: (client: BluzelleClient) => Promise<NodeStatusResponse>;
export declare const getValidators: (client: BluzelleClient) => Promise<ValidatorResponse[]>;
export declare const withTransaction: (client: BluzelleClient, fn: () => unknown) => Promise<DeliverTxResponse>;
export interface BroadcastOptions {
	gasPrice: number;
	maxGas: number;
	memo?: string;
}
export declare const pinCid: (client: BluzelleClient, cid: string, options: BroadcastOptions) => undefined;
export declare const send: (client: BluzelleClient, toAddress: string, amount: number, options: BroadcastOptions) => undefined;
export declare const delegate: (client: BluzelleClient, delegatorAddress: string, validatorAddress: string, amount: number, options: BroadcastOptions) => undefined;
export declare const undelegate: (client: BluzelleClient, delegatorAddress: string, validatorAddress: string, amount: number, options: BroadcastOptions) => undefined;
export declare const redelegate: (client: BluzelleClient, delegatorAddress: string, validatorSrcAddress: string, validatorDstAddress: string, amount: number, options: BroadcastOptions) => undefined;
export declare const withdrawDelegatorReward: (client: BluzelleClient, delegatorAddress: string, validatorAddress: string, options: BroadcastOptions) => undefined;

export {};
